
    export default [
  {
    "title": "Update Hari",
    "type": 0,
    "sectionRef": "#",
    "url": "blog/Update1",
    "content": "Ada Update Hari Pertama dan Kedua."
  },
  {
    "title": "Welcome",
    "type": 0,
    "sectionRef": "#",
    "url": "blog/Welcome",
    "content": "Selamat Menikmati, maaf jika tidak sempurna dalam translate bahasa inggrisnya."
  },
  {
    "title": "Style Guide#H1 - Create the best documentation",
    "type": 0,
    "sectionRef": "#",
    "url": "docs/doc1",
    "content": ""
  },
  {
    "title": "Markdown Syntax",
    "type": 1,
    "pageTitle": "Style Guide#H1 - Create the best documentation",
    "url": "docs/doc1#markdown-syntax",
    "content": "To serve as an example page when styling markdown based Docusaurus sites. "
  },
  {
    "title": "Headers",
    "type": 1,
    "pageTitle": "Style Guide#H1 - Create the best documentation",
    "url": "docs/doc1#headers",
    "content": "#H1 - Create the best documentation "
  },
  {
    "title": "H2 - Create the best documentation",
    "type": 1,
    "pageTitle": "Style Guide#H1 - Create the best documentation",
    "url": "docs/doc1#h2---create-the-best-documentation",
    "content": ""
  },
  {
    "title": "Emphasis",
    "type": 1,
    "pageTitle": "Style Guide#H1 - Create the best documentation",
    "url": "docs/doc1#emphasis",
    "content": "Emphasis, aka italics, with asterisks or underscores. Strong emphasis, aka bold, with asterisks or underscores. Combined emphasis with asterisks and underscores. Strikethrough uses two tildes. Scratch this.  "
  },
  {
    "title": "Lists",
    "type": 1,
    "pageTitle": "Style Guide#H1 - Create the best documentation",
    "url": "docs/doc1#lists",
    "content": "First ordered list itemAnother item ⋅⋅* Unordered sub-list.Actual numbers don't matter, just that it's a number ⋅⋅1. Ordered sub-listAnd another item. ⋅⋅⋅You can have properly indented paragraphs within list items. Notice the blank line above, and the leading spaces (at least one, but we'll use three here to also align the raw Markdown). ⋅⋅⋅To have a line break without a paragraph, you will need to use two trailing spaces.⋅⋅ ⋅⋅⋅Note that this line is separate, but within the same paragraph.⋅⋅ ⋅⋅⋅(This is contrary to the typical GFM line break behaviour, where trailing spaces are not required.) Unordered list can use asterisks Or minuses Or pluses  "
  },
  {
    "title": "Links",
    "type": 1,
    "pageTitle": "Style Guide#H1 - Create the best documentation",
    "url": "docs/doc1#links",
    "content": "I'm an inline-style link I'm an inline-style link with title I'm a reference-style link I'm a relative reference to a repository file You can use numbers for reference-style link definitions Or leave it empty and use the link text itself. URLs and URLs in angle brackets will automatically get turned into links. http://www.example.com or http://www.example.com and sometimes example.com (but not on Github, for example). Some text to show that the reference links can follow later.  "
  },
  {
    "title": "Images",
    "type": 1,
    "pageTitle": "Style Guide#H1 - Create the best documentation",
    "url": "docs/doc1#images",
    "content": "Here's our logo (hover to see the title text): Inline-style:  Reference-style:   "
  },
  {
    "title": "Code",
    "type": 1,
    "pageTitle": "Style Guide#H1 - Create the best documentation",
    "url": "docs/doc1#code",
    "content": "var s = 'JavaScript syntax highlighting';alert(s);Copy s = \"Python syntax highlighting\"print(s)Copy No language indicated, so no syntax highlighting.But let's throw in a <b>tag</b>.Copy function highlightMe() { console.log('This line can be highlighted!');}Copy  "
  },
  {
    "title": "Tables",
    "type": 1,
    "pageTitle": "Style Guide#H1 - Create the best documentation",
    "url": "docs/doc1#tables",
    "content": "Colons can be used to align columns.  Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1  There must be at least 3 dashes separating each header cell. The outer pipes (|) are optional, and you don't need to make the raw Markdown line up prettily. You can also use inline Markdown.  Markdown Less Pretty Still renders nicely 1 2 3   "
  },
  {
    "title": "Blockquotes",
    "type": 1,
    "pageTitle": "Style Guide#H1 - Create the best documentation",
    "url": "docs/doc1#blockquotes",
    "content": "Blockquotes are very handy in email to emulate reply text. This line is part of the same quote. Quote break. This is a very long line that will still be quoted properly when it wraps. Oh boy let's keep writing to make sure this is long enough to actually wrap for everyone. Oh, you can put Markdown into a blockquote.  "
  },
  {
    "title": "Inline HTML",
    "type": 1,
    "pageTitle": "Style Guide#H1 - Create the best documentation",
    "url": "docs/doc1#inline-html",
    "content": "Definition listIs something people use sometimes.Markdown in HTMLDoes *not* work **very** well. Use HTML tags.  "
  },
  {
    "title": "Line Breaks",
    "type": 1,
    "pageTitle": "Style Guide#H1 - Create the best documentation",
    "url": "docs/doc1#line-breaks",
    "content": "Here's a line for us to start with. This line is separated from the one above by two newlines, so it will be a separate paragraph. This line is also a separate paragraph, but... This line is only separated by a single newline, so it's a separate line in the same paragraph.  "
  },
  {
    "title": "Admonitions",
    "type": 1,
    "pageTitle": "Style Guide#H1 - Create the best documentation",
    "url": "docs/doc1#admonitions",
    "content": "This is a note ::: This is important ::: This is a warning ::: "
  },
  {
    "title": "H3 - Create the best documentation",
    "type": 1,
    "pageTitle": "Style Guide#H1 - Create the best documentation",
    "url": "docs/doc1#h3---create-the-best-documentation",
    "content": "#H4 - Create the best documentation #H5 - Create the best documentation #H6 - Create the best documentation  "
  },
  {
    "title": "Document Number 2",
    "type": 0,
    "sectionRef": "#",
    "url": "docs/doc2",
    "content": "This is a link to another document. This is a link to an external page."
  },
  {
    "title": "This is Document Number 3",
    "type": 0,
    "sectionRef": "#",
    "url": "docs/doc3",
    "content": "Lorem ipsum dolor sit amet, consectetur adipiscing elit. In ac euismod odio, eu consequat dui. Nullam molestie consectetur risus id imperdiet. Proin sodales ornare turpis, non mollis massa ultricies id. Nam at nibh scelerisque, feugiat ante non, dapibus tortor. Vivamus volutpat diam quis tellus elementum bibendum. Praesent semper gravida velit quis aliquam. Etiam in cursus neque. Nam lectus ligula, malesuada et mauris a, bibendum faucibus mi. Phasellus ut interdum felis. Phasellus in odio pulvinar, porttitor urna eget, fringilla lectus. Aliquam sollicitudin est eros. Mauris consectetur quam vitae mauris interdum hendrerit. Lorem ipsum dolor sit amet, consectetur adipiscing elit.Duis et egestas libero, imperdiet faucibus ipsum. Sed posuere eget urna vel feugiat. Vivamus a arcu sagittis, fermentum urna dapibus, congue lectus. Fusce vulputate porttitor nisl, ac cursus elit volutpat vitae. Nullam vitae ipsum egestas, convallis quam non, porta nibh. Morbi gravida erat nec neque bibendum, eu pellentesque velit posuere. Fusce aliquam erat eu massa eleifend tristique.Sed consequat sollicitudin ipsum eget tempus. Integer a aliquet velit. In justo nibh, pellentesque non suscipit eget, gravida vel lacus. Donec odio ante, malesuada in massa quis, pharetra tristique ligula. Donec eros est, tristique eget finibus quis, semper non nisl. Vivamus et elit nec enim ornare placerat. Sed posuere odio a elit cursus sagittis.Phasellus feugiat purus eu tortor ultrices finibus. Ut libero nibh, lobortis et libero nec, dapibus posuere eros. Sed sagittis euismod justo at consectetur. Nulla finibus libero placerat, cursus sapien at, eleifend ligula. Vivamus elit nisl, hendrerit ac nibh eu, ultrices tempus dui. Nam tellus neque, commodo non rhoncus eu, gravida in risus. Nullam id iaculis tortor.Nullam at odio in sem varius tempor sit amet vel lorem. Etiam eu hendrerit nisl. Fusce nibh mauris, vulputate sit amet ex vitae, congue rhoncus nisl. Sed eget tellus purus. Nullam tempus commodo erat ut tristique. Cras accumsan massa sit amet justo consequat eleifend. Integer scelerisque vitae tellus id consectetur."
  },
  {
    "title": "Hari Pertama - Apa Itu React",
    "type": 0,
    "sectionRef": "#",
    "url": "docs/hari1",
    "content": ""
  },
  {
    "title": "Fokus",
    "type": 1,
    "pageTitle": "Hari Pertama - Apa Itu React",
    "url": "docs/hari1#fokus",
    "content": "Hari ini kita akan belajar penuh dari awal. Kita akan belajar Apakah itu React dan mengapa begitu sangat tertarik. Kita akan diskusikan kenapa kita harus manfaatkan React. Selama 30 hari penuh, kamu akan merasa antusias dalam beberapa bagian dari React (https://facebook.github.io/react/) framework web dan bagian lainnya. Setiap hari selama 30 hari berpetualang, kita akan melaksanakan materi harian, jadi akhir seri pembelajaran, kamu tidak hanya faham tetntang aturan, konsep dan catatan lainnya, bagaimana framework bekerja tapi juga, dapat memanfaatkan React di Aplikasi Web selanjutnya. Kita mulai dengan melihat video ini (https://www.youtube.com/watch?v=1RW3nDRmu6k) sebagai awal dari pembelajaran, awal yang bagus. "
  },
  {
    "title": "Apa Itu React?",
    "type": 1,
    "pageTitle": "Hari Pertama - Apa Itu React",
    "url": "docs/hari1#apa-itu-react",
    "content": "React adalah Library dari JavaScript untuk membangun sebuah Tampilan. Sebuah View Layer untuk aplikasi web. Inti dari semua aplikasi React, adalah Komponen. Komponen itu sendiri terdiri dari modul yang merender keluaran data. Kita dapat menuliskan tampilan element, seperti button atau input, sebagai Komponen React. Komponennya sangat mudah dicampur. Sebuah komponen mungkin terdiri dari satu atau dua komponen lainnya dalam membangun tampilannya. Untuk menuliskan Komponen React yang dapat merespon beberapa element tampilan. Kita dapat mengaturnya di level komponene tertinggi yang dapat menggambarkan struktur dari aplikasi kita. Sebagai contoh, sebuah form. Sebuah form mungkin akan banyak tampilan elemen, seperti input, label dan buttons. Setiap elemen didalamnya dapat kita tulis dengan Komponen React. Kita akan tulis dalam bentuk level tertinggi dari komponen itu sendiri. Sebuah komponen form mungkin lebih spesifik dalam struktur dari form dan didalamnya sendiri terdapat tampilan elemen. Intinya, setiap komponen React sangat tergantung dari data secara umum. Kompleks, tampilan yang menarik seringkali melibatkan data yang kompleks dan state aplikasi. Pada area permukaan React sangat dibatasi dan tergantung dari kita, tools apa yang dapat diantisipasi bagian dari masalah. Kita akan bahas lebih dalam kelak di pelatihan. "
  },
  {
    "title": "Baik, Bagaimana memanfaatkan React?",
    "type": 1,
    "pageTitle": "Hari Pertama - Apa Itu React",
    "url": "docs/hari1#baik-bagaimana-memanfaatkan-react",
    "content": "React adalah Framework Javascript. Menggunakan Framework semudah menambahkan file Javascript ke file HTML dan gunakan React Export di aplikasi. Misalkan, Hello World, dalam React website tertulis seperti ini: <body> <div id=\"app\"></div> <script type=\"text/javascript\"> ReactDOM.render( <h1>Hello World</h1>, document.querySelector('#app') ) </script></body>Copy Wow, sedikit menakutkan, Kode JavaScript ditambahkan “Hello World” dalam baris yang dapat dirubah. Harap dicatat, kita hanya menambahkan script JavaScript agar dapat bekerja. "
  },
  {
    "title": "Bagaimana Cara Kerjanya?",
    "type": 1,
    "pageTitle": "Hari Pertama - Apa Itu React",
    "url": "docs/hari1#bagaimana-cara-kerjanya",
    "content": "Tidak seperti yang lain, itu hanya predecessors, React dapat bekerja tanpa langsung ke DOM (Data Object Manipulation) browser secara langsung, tapi dalam bentuk Virtual DOM. Begitulah, dibanding manipulasi sebuah object document dalam browser setelah perubahan data (dimana akan terkesan lama) dalam merubah sebuah DOM yang dibangun dan berjalan di memory. Setelah virtual DOM diubah, React akan menentukan apa yang telah dirubah di DOM browser anda. Sebuah React Virtual DOM yang eksis di memori dan di gambarkan oleh DOM browser. Karena inilah, ketika kita membuat sebuah komponen React, kita tidak langsung menuliskan langsung ke DOM, tapi kita menuliskan sebuah komponen virtual, dan React akan merubahnya ke dalam DOM browser. Dalam artikel selanjutnya, kita akan lebih memahaminya nanti, untuk apa kita bangun komponen React dan mempelajari JSX dan menuliskan komponen pertama kita. -- End Of Day 1 "
  },
  {
    "title": "Hari Kesupuluh",
    "type": 0,
    "sectionRef": "#",
    "url": "docs/hari10",
    "content": ""
  },
  {
    "title": "Hari Ke-11",
    "type": 0,
    "sectionRef": "#",
    "url": "docs/hari11",
    "content": ""
  },
  {
    "title": "Hari Ke-12",
    "type": 0,
    "sectionRef": "#",
    "url": "docs/hari12",
    "content": ""
  },
  {
    "title": "Hari Ke-13",
    "type": 0,
    "sectionRef": "#",
    "url": "docs/hari13",
    "content": ""
  },
  {
    "title": "Hari Ke-14",
    "type": 0,
    "sectionRef": "#",
    "url": "docs/hari14",
    "content": ""
  },
  {
    "title": "Hari Ke-15",
    "type": 0,
    "sectionRef": "#",
    "url": "docs/hari15",
    "content": ""
  },
  {
    "title": "Hari Ke-16",
    "type": 0,
    "sectionRef": "#",
    "url": "docs/hari16",
    "content": ""
  },
  {
    "title": "Hari Ke-17",
    "type": 0,
    "sectionRef": "#",
    "url": "docs/hari17",
    "content": ""
  },
  {
    "title": "Hari Ke-18",
    "type": 0,
    "sectionRef": "#",
    "url": "docs/hari18",
    "content": ""
  },
  {
    "title": "Hari Ke-19",
    "type": 0,
    "sectionRef": "#",
    "url": "docs/hari19",
    "content": ""
  },
  {
    "title": "Hari Kedua - Apa itu JSX",
    "type": 0,
    "sectionRef": "#",
    "url": "docs/hari2",
    "content": ""
  },
  {
    "title": "Apa Itu JSX?",
    "type": 1,
    "pageTitle": "Hari Kedua - Apa itu JSX",
    "url": "docs/hari2#apa-itu-jsx",
    "content": "Sekarang kita tahu apa itu React, saatnya kita lihat beberapa aturan dan konsep yang akan muncul di beberapa pembelajaran selanjutnya. Diartikel sebelumnya, kita sudah mengetahui apa itu React dan diskusikan cara kerjanya. Dalam artikel ini, kita akan membahas bagian dari Ekosistem React, yaitu ES6 dan JSX. "
  },
  {
    "title": "JSX/ ES5/ ES6, Apakah Itu??",
    "type": 1,
    "pageTitle": "Hari Kedua - Apa itu JSX",
    "url": "docs/hari2#jsx-es5-es6-apakah-itu",
    "content": "Dalam pencarian di Internet untuk material React, tidak masalah jika disebut JSX, ES5 dan ES6, Kebanyakan lawan kata membuat pusing pastinya. ES5 (arti ES artinya ECMAScript) secara dasar ialah sebuah “javascript pada umumnya”, update ke-5 telah ke javascript, yang selesai pada 2009. Semua scripts sudah didukung oleh semua browser beberapa tahun belakangan. Meskipun, kamu menulis atau melihat beberapa Javascript di masalalu, itu adalah ES5. ES6 merupakan versi terbaru dari JavaScript yang sudah ditambahkan sintaks dan fungsinya. Yang selesai pada 2015. ES6 didukung oleh semua browser. Tapi, itu terjadi ketika browser lama sudah lagi tidak didukung, sebagai contoh Internet Explorer 11, tidak mendukung ES6 tapi, mencakup 12% para pengguna secara umum. Untuk menjalankan keuntungan memanfaatkan ES6 sekarang, ada beberapa hal yang harus dilakukan agar bekerja di setiap browser, diantaranya: Kita harus trasnpile (merubah) code, agar semua browser faham tentang javascript. Itu artinya merubah ES6 Javascript ke ES5 Javascript.Kita harus menambahkan sebuah shim atau polyfill tambahan agar fungsi dari ES6 dapat bekerja, dimana tidak semua browser memilikinya. Kita akan coba sedikit setelah pemahasan kali ini. Hampir Semua kode dalam pembelajaran kali ini sangat mudah di ubah ke ES5. Dalam beberapa kasus kita gunakan ES6, dan akan menjelaskan keuntungan mamanfaatkanya. Kita sudah pelajari, Komponen React memiliki Fungsi “Render” yang bekerja sebagai keluaran HTML, dimana Komponen React Berada. JavaScript eXtention, atau biasa disebut JSX, adalah Ekstensi React yang mengijinkan kita menulis JavaScript seperti HTML. Baiklah, inilah beberapa contoh komponen React, agar memiliki gambaran dari fungsi Render, h1 sebagai tag HTML. Jsx membolehkan mendeklarasikan element HTML sebagai Komponen dari React. class HelloWorld extends React.Component { render() { return <h1 className=\"large\">Hello World</h1>; }}Copy Fungsi render di komponen HelloWorld terlihat seperti keluaran HTML, tapi itu adalah JSX. Sebuah JSX dapat metranslate ke JavaScript Umum saat disimpan-reload. Komponen tersebut terlihat seperti berikut, setelah di translate. class HelloWorld extends React.Component { render() { return React.createElement(\"h1\", { className: \"large\" }, \"Hello World\"); }}Copy Lihat JSX seperti HTML, sebetulnya itu hanyalah cara menulis lain dari sebuah potongan kodel deklarasi React.createElement(). Ketika komponen dirender, itu hanya sebuah baris Komponen React, atau biasa disebut “Virtual Represntation dari HTML”, jadi Element react menentukan apa yang dirubah berdasarkan DOM sebenarnya di elemen react. Komponen HelloWorl, sebuah HTML yang terbentuk ke DOM akan terlihat seperti ini: <h1 className=\"large\">Hello world</h1>Copy Dalam sintak tersebut itu adalah komponen React pertama ialah ES6 sintak. Yang dapat menuliskan object dengan OO (object oriented) style. ES6 sintak class yang di translate seperti ini: var helloWorld = function() {};Object.extends(HelloWorld, React.Component);HelloWorld.prototype.render = function() {};Copy Karena JSX ialah JavaScript, kita tidak dapat menggunakan katakunci javascript, termasuk kata class dan for. React memberikan kita penambahan attribute className. Kita gunakan itu di HelloWorld yaitu kelas large di h1 tag. Ada beberapa atribute, seperti for, untuk React ke htmlFor sebagai for yang mana itu katakunci. Kita akan lihat saat kita belajar nanti. Jika kita ingin menuliskan murni JavaSCript dibanding memanfaatkan JSX compiler, kita bisa tuliskan fungsi React.createElement() dan tidak usah khawatir akan abstraction layer. Kita suka JSX karena memudahkan membaca komponen yang kompleks, berikut contohnya: <div> <img src=\"profile.jpg\" alt=\"Profile Photo\" /> <h1>Welcome to React!</h1></div>Copy Dalam JavaScript akan terbaca oleh browser sebagai berikut: React.createElement( \"div\", null, React.createElement(\"img\", { src: \"profile.jgp\", alt: \"Profile Photo\" }), React.createElement(\"h1\", null, \"Welcome to React!\"));Copy Sekali lagi, kita akan lewati dahulu JSX dan cara penulisannya, sintak JSX sangat menggoda dalam menampilkan element HTML. Sekarang kita faham apa itu JSX, kita akan menulis komponen React pertama, gabunglah dengan kami, ketika kita menuliskan aplikasi React Pertama. -- End of Day 2 "
  },
  {
    "title": "Hari Ke-20",
    "type": 0,
    "sectionRef": "#",
    "url": "docs/hari20",
    "content": ""
  },
  {
    "title": "Hari Ke-21",
    "type": 0,
    "sectionRef": "#",
    "url": "docs/hari21",
    "content": ""
  },
  {
    "title": "Hari Ke-22",
    "type": 0,
    "sectionRef": "#",
    "url": "docs/hari22",
    "content": ""
  },
  {
    "title": "Hari Ke-23",
    "type": 0,
    "sectionRef": "#",
    "url": "docs/hari23",
    "content": ""
  },
  {
    "title": "Hari Ke-24",
    "type": 0,
    "sectionRef": "#",
    "url": "docs/hari24",
    "content": ""
  },
  {
    "title": "Hari Ke-25",
    "type": 0,
    "sectionRef": "#",
    "url": "docs/hari25",
    "content": ""
  },
  {
    "title": "Hari Ke-26",
    "type": 0,
    "sectionRef": "#",
    "url": "docs/hari26",
    "content": ""
  },
  {
    "title": "Hari Ke-27",
    "type": 0,
    "sectionRef": "#",
    "url": "docs/hari27",
    "content": ""
  },
  {
    "title": "Hari Ke-28",
    "type": 0,
    "sectionRef": "#",
    "url": "docs/hari28",
    "content": ""
  },
  {
    "title": "Hari Ke-29",
    "type": 0,
    "sectionRef": "#",
    "url": "docs/hari29",
    "content": ""
  },
  {
    "title": "Hari Ketiga - Komponen Pertama",
    "type": 0,
    "sectionRef": "#",
    "url": "docs/hari3",
    "content": ""
  },
  {
    "title": "Komponen Pertama Kita",
    "type": 1,
    "pageTitle": "Hari Ketiga - Komponen Pertama",
    "url": "docs/hari3#komponen-pertama-kita",
    "content": "2 Artikel sebelumnya dalam series ini telah kita diskusikan. Saatnya, lebih dalam lagi menulis code dan aplikasi react pertama. Kita ubah File “Hello World” yang sebelumnya. Ini dia, beberapa perubahan kecil: <!DOCTYPE html><html><head> <meta charset=\"utf-8\"> <title>Hello world</title> <!-- Script tags including React --> <script src=\"https://cdnjs.cloudflare.com/ajax/libs/react/15.3.1/react.min.js\"></script> <script src=\"https://cdnjs.cloudflare.com/ajax/libs/react/15.3.1/react-dom.min.js\"></script> <script src=\"https://unpkg.com/babel-standalone@6/babel.min.js\"></script></head><body> <div id=\"app\"></div> <script type=\"text/babel\"> var app = <h1>Hello world</h1> var mountComponent = document.querySelector('#app'); ReactDOM.render(app, mountComponent); </script></body></html>Copy "
  },
  {
    "title": "Menjalankan Librari React",
    "type": 1,
    "pageTitle": "Hari Ketiga - Komponen Pertama",
    "url": "docs/hari3#menjalankan-librari-react",
    "content": "Kita sudah jalankan librari React sebagai <script>, di tag <head> dihalaman tersebut. Ini sangat penting menempatkan <script> kita sebelum kita memulai aplikasi dengan React, dengan katalain variabel React dan ReactDOM tidak akan didefinisikan diawal untuk kita gunakan. Juga di tag head terdapat sebuat script lainnya, babel-core. apa itu? "
  },
  {
    "title": "Komponen dan lainnya",
    "type": 1,
    "pageTitle": "Hari Ketiga - Komponen Pertama",
    "url": "docs/hari3#komponen-dan-lainnya",
    "content": "Kita sudah jelaskan diawal dari seris ini, inti dari React adalah berbagai komponen cara tebaik untuk memahami komponen React ya menuliskannya. Kita akan tulis komponen React kita sebagai class ES6. Kita lihat sebuah komponen kita sebut App. Seperti komponen React lainnya, class ES6 akan meng-extend React.Component class dari paket React. class App extends React.Component { render() { return <h1>Hello from our App</h1>; }}Copy semua komponen React diakhiri dengan fungsi render(). fungsi ini akan mengembalikan nilai sebagai virtual DOM, dari sebuah elemen DOM Browser. contoh Play kita akan ubah script Javascript tersebut ke komponen App. <!DOCTYPE html><html><head> <meta charset=\"utf-8\"> <title>Hello world</title> <!-- Script tags including React --> <script src=\"https://cdnjs.cloudflare.com/ajax/libs/react/15.3.1/react.min.js\"></script> <script src=\"https://cdnjs.cloudflare.com/ajax/libs/react/15.3.1/react-dom.min.js\"></script> <script src=\"https://unpkg.com/babel-standalone@6/babel.min.js\"></script></head><body> <div id=\"app\"></div> <script type=\"text/babel\"> class App extends React.Component { render() { return <h1>Hello from our App</h1> } } var mount = document.querySelector('#app'); ReactDOM.render(<App />, mount); </script></body></html>Copy bagaimanapun, kita tidak akan melihatnya dilayar, tau kenapa? kita belum memberikan perintah ke React untuk menampilkan apapun di React atau dimana untuk merendernya. Kita butuh fungsi ReactDOM.render() untuk menampilkannya. Tambahkan fungsi tersebut,maka akan muncul dilayar kita. var mount = document.querySelector(\"#app\");ReactDOM.render(<App />, mount);Copy Harap diperhatikan, dalam app React kita, kita gunakan class App sebagai komponen DOM (seperti tag <h1 /> dan <div />). Disini kita gunakan sebagai element dengan ditutup langsung <App />. Ide dari komponen-komponen React seperti element dihalaman yang seperti pohon (bercabang), hanya sebuah cabang browser native. Saat kita sekarang render komponen React, aplikasi kita masih jauh dari kehebatan atau interaktif. Berikutnya, kita akan lihat bagaimana memanfaatkan komponen React sebagai pengolah data dan bersifat dinamis. Tapi, dilangkah selanjutnya dalam seris ini, kita akan mendalami bagaimana sebuah layer komponen. Komponen bercabang adalah fondasi dari aplikasi React yang glamor. -- End of Day 3 "
  },
  {
    "title": "Babel",
    "type": 1,
    "pageTitle": "Hari Ketiga - Komponen Pertama",
    "url": "docs/hari3#babel",
    "content": "Pada hari ke-2 kita sudah bahas tentang ES5 dan ES6. Sudah disinggung ES6 masih tahap peremajaan. Untuk bisa gunakan ES6, langkah terbaiknya kita ubah ES6 Javascript ke ES5 Javascript yang sudah didukung oleh semua browser. Babel adalah library untuk mengubah ES6 ke ES5. Di tag body kita sudah punya script. Didalam script tersebut kita sudah definisikan Aplikasi React Pertama. Harap diperhatikan tag script dengan dituliskan text/babel. <script type=\"text/babel\">Copy tag type tersebut memberikan kode ke Babel untuk segera mengeksekusi Javascript didalam tag body script, ini adalah cara untuk menulis aplikasi React menggunakan ES6 Javascript dan dipastikan bahwa Babel akan langsung merubah dibrowser, yang support hanya ES5. "
  },
  {
    "title": "Sebuah Aplikasi React",
    "type": 1,
    "pageTitle": "Hari Ketiga - Komponen Pertama",
    "url": "docs/hari3#sebuah-aplikasi-react",
    "content": "Didalam tag body script Babel, kita sudah definisikan aplikasi React pertama. Aplikasi kita hanya menampilkan satu element, <h1>Hello World</h1>. Dipanggil oleh ReactDOM.render() yang sebetulnya aplikasi kecil kita ada dihalaman tersebut. Tanpa dipanggil oleh ReactDOM.render() maka tidak akan muncul di DOM. Argumen pertama dari ReactDOM.render() adalah apa yang mau dirender, sedangkan argumen kedua adalah dimana itu dirender. ReactDOM.render(<what>, <where>)Copy Kita sudah tuliskan aplikasi pertama kita, dengan menuliskan tag h1. Serius, ini tidak menarik. Aplikasi web yang keren terdiri dari inputan user, halaman yang dinamis setiap halaman dan berkomunikasi dengan server web. Baiklah, kita mulai dengan membangun aplikasi Kompoenen React. "
  },
  {
    "title": "Hari Ke-30",
    "type": 0,
    "sectionRef": "#",
    "url": "docs/hari30",
    "content": ""
  },
  {
    "title": "Hari Keempat - Komponen Kompleks",
    "type": 0,
    "sectionRef": "#",
    "url": "docs/hari4",
    "content": ""
  },
  {
    "title": "Komponen Kompleks",
    "type": 1,
    "pageTitle": "Hari Keempat - Komponen Kompleks",
    "url": "docs/hari4#komponen-kompleks",
    "content": "Keren, kita sudah buat komponen pertama. Sekarang kita akan buat lebih menarik dan mulai membangun tampilan yang kompleks. Dalam pelajaran sebelumnya, kita sudah buat komponen pertama, dan pada pelajaran kali ini, kita akan lanjutkan dengan komponen App dan UI (user interface) yang kompleks. Sebuah web pada umumnya, mungkin mudah terlihatnya. Sebagai contoh, kita mungkin punya aplikasi yang menampilkan sebuah cerita yang terjadi di aplikasi Facebook dan Twitter. "
  },
  {
    "title": "Penjelasan",
    "type": 1,
    "pageTitle": "Hari Keempat - Komponen Kompleks",
    "url": "docs/hari4#penjelasan",
    "content": "Ketimbang membuat dalam 1 komponen, kita pecah menjadi beberapa komponen. Melihat dari contoh diaatas, bisa kita pisahkan menjadi 2 bagian komponen besar, diantaranya: JudulIsi  kitapun masih bisa membagi isi menjadi 3 bagian lainnya.  Jika kita ingin lebih cepat, kita akan pecah juga judul menjadi 3 bagian, tombol menu, tulisan judul, dan tombol pencarian, kita bisa kerjakan itu, jika kita mau. Penentuan dalam memecah setiap komponen tidak lebih seperti seni ketimbang pengetahuan atau kemampun dalam pengembangan aplikasi. Dalam beberapa kasus, penting dalam memulai untuk setiap aplikasi dimulai dari berbagai komponen. Dengan memecah app kebeberapa komponen memudahkan untuk ujicoba dan memantau kegunaan komponen tersebut. "
  },
  {
    "title": "Komponen Kontainer",
    "type": 1,
    "pageTitle": "Hari Keempat - Komponen Kompleks",
    "url": "docs/hari4#komponen-kontainer",
    "content": "Untuk membangun app notifikasi, kita akan bangun sebuah kontainer yang menampung app. Kontainer kita itu mudah, yang dapat menampung 2 komponen sekaligus. Tidak semua komponen membutuhkan fungsi khusus (belum saatnya), jadi mungkin akan terlihat seperti komponen Hello World dengan 1 kali render. Baiklah, kita buat komponen App, seperti dibawah ini: class App extends React.Component { render() { return ( <div className=\"demo\"> <div className=\"notificationsFrame\"> <div className=\"panel\">{/* isi disini */}</div> </div> </div> ); }}Copy Catat!Harap diingat, kita menggunakan tag className dalam React ketimbang class dari HTML, karena kita tidak menuliskan DOM secara langsung maupun HTML, melainkan JSX. Selain itu class adalah kata yang tidak boleh dipake lagi di Javascript. "
  },
  {
    "title": "Komponen Child",
    "type": 1,
    "pageTitle": "Hari Keempat - Komponen Kompleks",
    "url": "docs/hari4#komponen-child",
    "content": "Ketika komponen dibutuhkan didalam komponen lainnya, itulah dinamakan komponen child. Sebuah komponen bisa saja mempunyai banyak komponen lainnya. Sebuah komponen yang memanfaatkan komponen child biasa disebut komponen parrent. Dengan komponen yang sudah didefinisikan, kita dapat komponen judul dan isi, pada dasarnya, memecah design utama kita ke beberapa bagian komponen. Sebagai contoh, komponen header, dengan elementya <div className=\"header\">, ikon menu, judul, dan pencarian. Live Editorclass Judul extends React.Component { render() { return ( <div className=\"demo\"> <div className=\"notificationsFrame\"> <div className=\"panel\"> <div className=\"header\"> <div className=\"menuIcon\"> <div className=\"dashTop\"></div> <div className=\"dashBottom\"></div> <div className=\"circle\"></div> </div> <span className=\"title\">TimeLine</span> <input type=\"text\" className=\"searchInput\" placeholder=\"Search... \" /> <div className=\"fa fa-search searchIcon\"></div> </div> </div> </div> </div> ); } }class Judul extends React.Component { render() { return ( <div className=\"demo\"> <div className=\"notificationsFrame\"> <div className=\"panel\"> <div className=\"header\"> <div className=\"menuIcon\"> <div className=\"dashTop\"></div> <div className=\"dashBottom\"></div> <div className=\"circle\"></div> </div> <span className=\"title\">TimeLine</span> <input type=\"text\" className=\"searchInput\" placeholder=\"Search... \" /> <div className=\"fa fa-search searchIcon\"></div> </div> </div> </div> </div> ); }}ResultTimeLine dan terakhir, kita akan membuat komponen isi dengan item timeline. Setiap timeline dibungkus dalam 1 komponen, terdiri dari avatar, waktu dan kalimat singkat. Live Editorclass Isi extends React.Component { render() { return ( <div className=\"demo\"> <div className=\"notificationsFrame\"> <div className=\"content\"> <div className=\"line\"></div> {/* item timeline */} <div className=\"item\"> <div className=\"avatar\"> <img alt=\"Doug\" src=\"http://www.croop.cl/UI/twitter/images/doug.jpg\" />{\" \"} Doug </div> <span className=\"time\">An hour ago</span> <p>Ate Lunch</p> <div className=\"commentCount\">2</div> </div> {/* .... */} </div> </div> </div> ); } }class Isi extends React.Component { render() { return ( <div className=\"demo\"> <div className=\"notificationsFrame\"> <div className=\"content\"> <div className=\"line\"></div> {/* item timeline */} <div className=\"item\"> <div className=\"avatar\"> <img alt=\"Doug\" src=\"http://www.croop.cl/UI/twitter/images/doug.jpg\" />{\" \"} Doug </div> <span className=\"time\">An hour ago</span> <p>Ate Lunch</p> <div className=\"commentCount\">2</div> </div> {/* .... */} </div> </div> </div> ); }}Result DougAn hour agoAte Lunch2 PerhatianUntuk menulis komentar di komponen React kita gunakan bracket sebagi multi-line komentar di javascript. Tidak seperti komentar HTML, seperti dibawah ini:<!-- INI KOMENTAR HTML -->Copy di React, sebuah komponen ditutup dengan bracket:{ /* INI KOMENTAR DI REACT */ }Copy "
  },
  {
    "title": "Gabungkan Semua",
    "type": 1,
    "pageTitle": "Hari Keempat - Komponen Kompleks",
    "url": "docs/hari4#gabungkan-semua",
    "content": "Sekarang kita akan gabungkan 2 komponen child, yaitu Judul dan Isi, merupakan komponen child bagian dari komponen App. Kurang lebih akan menjadi seperti dibawah ini: class App extends React.Component { render() { return ( <div className=\"notificationsFrame\"> <div className=\"panel\"> <Judul /> <Isi /> </div> </div> ); }}Copy TODO: JSX LIVE STYLE. Selesai, selanjutnya kita akan buat sebuah komponen lebih dinamis dan menjadi pengolah data dengan React. "
  },
  {
    "title": "CSS",
    "type": 1,
    "pageTitle": "Hari Keempat - Komponen Kompleks",
    "url": "docs/hari4#css",
    "content": "Sekedar info, kita tidak fokus di CSS dalam pembelajaran kali ini, kita tidak akan bahas CSS secara spesifik dalam membangun sebuah cerita seperti dilayar. Bagaimanapun, kita akan bangun semirip mungkin. Jika anda mengikutsertakan file CSS sebagai tag <link /> di kode anda, mungkin akan terlihat sama dengan style yang kita pakai:<link href=\"https://rawcdn.githack.com/fullstackreact/30-days-of-react/204f0bcc31a795771e75cec956710828a0fd1f74/day-04/public/Timeline.css\" rel=\"stylesheet\" type=\"text/css\"/>Copydan pastikan kode dalam komponen demo sama dengan yang tersedia, cek dihalaman ini: https://jsfiddle.net/auser/zwomnfwk/ untuk contoh.Semua kode CSS ada dihalaman ini: https://github.com/fullstackreact/30-days-of-react/blob/master/day-04/public/Timeline.css Kita akan buat 1 komponen UI. Bagaimanapun, membangun aplikasi dalam 1 komponen itu sangat tidak bagus, akan kompleks dan sulit untuk diujicoba. Live Editorclass Timeline extends React.Component { render() { return ( <div class=\"demo\"> <div className=\"notificationsFrame\"> <div className=\"panel\"> <div className=\"header\"> <div className=\"menuIcon\"> <div className=\"dashTop\"></div> <div className=\"dashBottom\"></div> <div className=\"circle\"></div> </div> <span className=\"title\">Timeline</span> <input type=\"text\" className=\"searchInput\" placeholder=\"Search ...\" /> <div className=\"fa fa-search searchIcon\"></div> </div> <div className=\"content\"> <div className=\"line\"></div> <div className=\"item\"> <div className=\"avatar\"> <img alt=\"doug\" src=\"http://www.croop.cl/UI/twitter/images/doug.jpg\" /> </div> <span className=\"time\">An hour ago</span> <p>Ate lunch</p> </div> <div className=\"item\"> <div className=\"avatar\"> <img alt=\"doug\" src=\"http://www.croop.cl/UI/twitter/images/doug.jpg\" /> </div> <span className=\"time\">10 am</span> <p>Read Day two article</p> </div> <div className=\"item\"> <div className=\"avatar\"> <img alt=\"doug\" src=\"http://www.croop.cl/UI/twitter/images/doug.jpg\" /> </div> <span className=\"time\">10 am</span> <p> Lorem Ipsum is simply dummy text of the printing and typesetting industry. </p> </div> <div className=\"item\"> <div className=\"avatar\"> <img alt=\"doug\" src=\"http://www.croop.cl/UI/twitter/images/doug.jpg\" /> </div> <span className=\"time\">2:21 pm</span> <p> Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. </p> </div> </div> </div> </div> </div> ); } }class Timeline extends React.Component { render() { return ( <div class=\"demo\"> <div className=\"notificationsFrame\"> <div className=\"panel\"> <div className=\"header\"> <div className=\"menuIcon\"> <div className=\"dashTop\"></div> <div className=\"dashBottom\"></div> <div className=\"circle\"></div> </div> <span className=\"title\">Timeline</span> <input type=\"text\" className=\"searchInput\" placeholder=\"Search ...\" /> <div className=\"fa fa-search searchIcon\"></div> </div> <div className=\"content\"> <div className=\"line\"></div> <div className=\"item\"> <div className=\"avatar\"> <img alt=\"doug\" src=\"http://www.croop.cl/UI/twitter/images/doug.jpg\" /> </div> <span className=\"time\">An hour ago</span> <p>Ate lunch</p> </div> <div className=\"item\"> <div className=\"avatar\"> <img alt=\"doug\" src=\"http://www.croop.cl/UI/twitter/images/doug.jpg\" /> </div> <span className=\"time\">10 am</span> <p>Read Day two article</p> </div> <div className=\"item\"> <div className=\"avatar\"> <img alt=\"doug\" src=\"http://www.croop.cl/UI/twitter/images/doug.jpg\" /> </div> <span className=\"time\">10 am</span> <p> Lorem Ipsum is simply dummy text of the printing and typesetting industry. </p> </div> <div className=\"item\"> <div className=\"avatar\"> <img alt=\"doug\" src=\"http://www.croop.cl/UI/twitter/images/doug.jpg\" /> </div> <span className=\"time\">2:21 pm</span> <p> Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. </p> </div> </div> </div> </div> </div> ); }}ResultTimelineAn hour agoAte lunch10 amRead Day two article10 amLorem Ipsum is simply dummy text of the printing and typesetting industry.2:21 pmLorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. "
  },
  {
    "title": "Hari Kelima - Data Driven",
    "type": 0,
    "sectionRef": "#",
    "url": "docs/hari5",
    "content": ""
  },
  {
    "title": "Data Driven",
    "type": 1,
    "pageTitle": "Hari Kelima - Data Driven",
    "url": "docs/hari5#data-driven",
    "content": "Catatan!Menuliskan data dalam baris kode itu sangat tidak baik. Hari ini, kita akan merubah komponen yang dapat mengaksess data dari luar Dari Poin ini, kita sudah tuliskan komponen kita dan saling berhubung antar komponen parent atau child. Bagaimanapun, kita belum mencoba data dikomponen React, meski tergantung kebutuhan (menurut kami) didalam website dengan React, kita masih belum mengambil kekuatan React dalam menampilkan data. Baiklah, kita mulai sekarang. "
  },
  {
    "title": "Mencoba data-driven",
    "type": 1,
    "pageTitle": "Hari Kelima - Data Driven",
    "url": "docs/hari5#mencoba-data-driven",
    "content": "Cek ulang, kemarin kita sudah buat dari awal komponen timeline, didalamnya terdapat sebuah komponen judul dan isi (aktivitas), cek dihalaman https://github.com/topidesta/30hariCode Kita membagi beberapa bagian komponen, yang terdiri dari 3 komponen bagian yang berbeda, dengan template JSX statis. Sangat tidak nyaman setiap ada update di template komponen, untuk perubahan data diwebsite kita. Baiklah, kita mulai menampilkan data. Kita mulai dari komponen <Judul />. Komponen tersebut hanya menampilkan judul dari element Timeline. Sangat bagus, jika kita gunakan kembali bagian bagian komponen dihalaman lainnya, tapi tidak begitu berpengaruh untuk judul Timeline dalam penggunaannya. Baiklah, katakan kita sudah siap untuk menambahkan judul ke React atau semacamnya. "
  },
  {
    "title": "Pengenalan Props",
    "type": 1,
    "pageTitle": "Hari Kelima - Data Driven",
    "url": "docs/hari5#pengenalan-props",
    "content": "React menginjinkan kita mengirim data ke komponen layaknya sebuah sintak HTML, menggunakan attribute atau properties dalam komponen. Ini sama seperti menampilkan gambar dengan memanfaatkan tag src. Kita berfikir tentang property tag <img /> sebagai prop yang sudah kita buat dikomponen, kita sebut img. Kita dapat akses properties dalam sebuah komponen dengan this.props. Baiklah, waktunya kitacoba. Tulis ulang kembali komponen judul: Live Editorclass Judul extends React.Component { render() { return ( <div className=\"demo\"> <div className=\"notificationsFrame\"> <div className=\"header\"> <div className=\"menuIcon\"> <div className=\"dashTop\"></div> <div className=\"dashBottom\"></div> <div className=\"circle\"></div> </div> <span className=\"title\">Timeline</span> <input type=\"text\" className=\"searchInput\" placeholder=\"Search ...\" /> <div className=\"fa fa-search searchIcon\"></div> </div> </div> </div> ); } }class Judul extends React.Component { render() { return ( <div className=\"demo\"> <div className=\"notificationsFrame\"> <div className=\"header\"> <div className=\"menuIcon\"> <div className=\"dashTop\"></div> <div className=\"dashBottom\"></div> <div className=\"circle\"></div> </div> <span className=\"title\">Timeline</span> <input type=\"text\" className=\"searchInput\" placeholder=\"Search ...\" /> <div className=\"fa fa-search searchIcon\"></div> </div> </div> </div> ); }}ResultTimeline Ketika kita gunakan bernama komponen <Judul />, kita simpan di komponen <App />, seperti ini: <Judul />Copy Kita bisa tambahkan attribute title sebagai prop di komponen <Judul />, dengan attributenya kurang lebih seperti ini: <Judul title=\"Timeline\" />Copy Dalam komponen kita, kita dapat akses propertis title dari class Judul dengan this.props. Dibanding kita harus set secara manual di template, kita dapat gunapakan propertis untuk menghandlenya. class Judul extends React.Component { render() { return ( <div className=\"demo\"> <div className=\"notificationsFrame\"> <div className=\"header\"> <div className=\"menuIcon\"> <div className=\"dashTop\"></div> <div className=\"dashBottom\"></div> <div className=\"circle\"></div> </div> <span className=\"title\">{this.props.title}</span> <input type=\"text\" className=\"searchInput\" placeholder=\"Search ...\" /> <div className=\"fa fa-search searchIcon\"></div> </div> </div> </div> ); }}Copy infoBerikut ini source dari git: https://github.com/topidesta/30hariCode/commit/6aece32cc1e1d1ed1e5ba423744e5d5d319d7604 Kita juga bisa tambahkan komponen <Judul /> yang akan menampilkan string sebagai title ketika komponen dipanggil, cukup dengan menuliskannya sebanyak 4x, seperti dibawah ini <Judul title=\"Timeline\" /><Judul title=\"Profile\" /><Judul title=\"Settings\" /><Judul title=\"Chat\" />Copy maka, akan muncul 4 menu tambahan, kurang lebih seperti dibawah ini:  infoini link livenya: https://5e7c524149d2df0008131180--30haricode.netlify.com/ Nah, mudahbukan? sekarang kita dapat menggunakan berulang-ulang komponen <Judul /> dengan propertis title yang dinamis. Kita dapat menambahkan tidak hanya sebuah string di komponen. Kita dapat tambahkan nomor, string, objek dan fungsi pun bisa. Kita sedang membicarakan definisi lain dari prorperties, selanjutnya kita akan buat komponen API. Ketimbang mengatur isi dan tanggal secara manual, kita bisa gunakan komponen isi dengan variable data ketimbang dengan text manual. Sama seperti kita lakukan dengan komponen HTML, kita dapat lewati banyak properties ke sebuah komponen. Kemarin kita sudah buat komponen isi kurang lebih seperti ini: class Isi extends React.Component { render() { return ( <div className=\"content\"> <div className=\"line\"></div> {/* Timeline item */} <div className=\"item\"> <div className=\"avatar\"> <img src=\"http://www.croop.cl/UI/twitter/images/doug.jpg\" /> Doug </div> <span className=\"time\">An hour ago</span> <p>Ate lunch</p> <div className=\"commentCount\">2</div> </div> {/* ... */} </div> ); }}Copy sama seperti title sebelumnya, mari kita lihat props di komponen isi yang dibutuhkan, diantarnya: Gambar avatar penggunaAktifitas WaktuText dari item aktifitasJumlah komentar Anggap saja, kita punya data berupa object Javascript yang menggambarkan isi aktivitas. Kita punya beberapa field, seperti string (text) dan objek waktu. Kita mungkin butuh beberapa turunan lainnya seperti komentar dan pengguna, seperti berikut: { timestamp: new Date().getTime(), text: \"Ate Lunch\", pengguna: { id: 1, nama: 'Nate', Avatar: 'http://www.croop.cl/UI/twitter/images/doug.jpg' }, komentar: [ { from: 'Ari', text: 'Me too!' } ]}Copy Sekarang kita buat sebuah objek yang terdiri dari berbagai aktifitas, seperti dibawah ini: const activities = [ { timestamp: new Date().getTime(), text: \"Ate lunch\", pengguna: { id: 1, nama: \"Nate\", avatar: \"http://www.croop.cl/UI/twitter/images/doug.jpg\" }, komentar: [{ from: \"Ari\", text: \"Me too!\" }] }, { timestamp: new Date().getTime(), text: \"Woke up early for a beautiful run\", pengguna: { id: 2, nama: \"Ari\", avatar: \"http://www.croop.cl/UI/twitter/images/doug.jpg\" }, komentar: [{ from: \"Nate\", text: \"I am so jealous\" }] }];Copy Tambahkan di komponen <Isi /> dalam 1 baris: <Content activities={activities} />Copy Simpan Object di Komponen App ya, atau cek disourcecode berikut ini: https://github.com/topidesta/30hariCode/commit/f94c69b833ee7be3b36306a7518761085610136c Coba direfresh, tidak akan muncul, kita perlu update komponen Isi terlebih dahulu untuk menerima banyak data, sebagaimana kita pelajari sebelumnya, JSX hanya sekedar JavaScript yang dieksekusi oleh browser. Kita akan eksekusi didalam konten JSX. Baiklah, kita gunakan fungsi map dari Javascript, untuk memecah setiap itemnyah, kurang lebih seperti dibawah ini: class Isi extends React.Component { render() { const { activities } = this.props; // ES6 destructuring return ( <div className=\"content\"> <div className=\"line\"></div> {/* Timeline item */} {activities.map(activity => { return ( <div className=\"item\"> <div className=\"avatar\"> <img alt={activity.text} src={activity.pengguna.avatar} /> {activity.pengguna.nama} </div> <span className=\"time\">{activity.timestamp}</span> <p>{activity.text}</p> <div className=\"commentCount\">{activity.komentar.length}</div> </div> ); })} {/* ... */} </div> ); }}Copy  Live Perubahan: https://5e7c6e892de05200080c9a41--30haricode.netlify.com/Source Perubahan: https://github.com/topidesta/30hariCode/commit/04cf33642fa2e31728e1767375a57448a64de1db#diff-16f661b3c05bfec7014e09a54aaee062 Sekarang kita bisa lihat array dalam bentuk aktifitas dan kompoen isi yang akan mengaturnya. bagaimanapun kita bisa menambahkan berapapun array, lalu kita hubungkan dengan komponen lebih kompleks, antara isi dan daftar aktifitas. "
  },
  {
    "title": "ItemAktifitas",
    "type": 1,
    "pageTitle": "Hari Kelima - Data Driven",
    "url": "docs/hari5#itemaktifitas",
    "content": "Disini kita akan buat sedikit 1 komponen yang menampilkan aktifitas dan dibanding membuat komponen Isi yang kompleks, kita fahami itu. Hal itu memudahkan untuk pengetesan, penambahan fungsi dan lainnya. Baiklah, waktunya ubah komponen Isi dalam menampilkan daftar aktifitas ItemAktifitas (kita akan tulis, nanti ya!). class Isi extends React.Component { render() { const { activities } = this.props; //es6 destructing return ( <div className=\"content\"> <div className=\"line\"> {activities.map(activity => { <ItemAktifitas activity={activity} />; })} </div> </div> ); }}Copy Tidak hanya mudah dibaca dan lebih sederhana, tapi memudahkan untuk melakukan test antar komponen. Dengan kode komponen Isi yang baru, sekarang kita buat komponen ItemAktifitas, yang kita butuhkan kopi data dari komponen Isi sebelumnya, yang pernah kitabuat. class ItemAktifitas extends React.Component { render() { const { activity } = this.props; return ( <div className=\"item\"> <div className=\"avatar\"> <img alt={activity.text} src={activity.user.avatar} /> {activity.user.name} </div> <span className=\"time\">{activity.timestamp}</span> <p>{activity.text}</p> <div className=\"commentCount\">{activity.comments.length}</div> </div> ); }}Copy source perubahan: https://github.com/topidesta/30hariCode/commit/c79cf99efbb97346a16d688b78689b09e0e19fcdlive perubahan: https://5e7d79e9a03bc90008984161--30haricode.netlify.com/ Hari ini kita sudah melakukan perubahan di komponen kita dengan data yang tersedia, menggunakan konsep props di React. Selanjutnya, kita akan masuk pada komponen stateful. "
  },
  {
    "title": "Hari Keenam - State",
    "type": 0,
    "sectionRef": "#",
    "url": "docs/hari6",
    "content": ""
  },
  {
    "title": "Sebuah State",
    "type": 1,
    "pageTitle": "Hari Keenam - State",
    "url": "docs/hari6#sebuah-state",
    "content": "React tidak mengijinkan kita memodifikasi this.props setiap komponen untuk suatu alasan. Bayangkan jika kita dapat merubah prop title pada komponen Judul. Kita akan dihadapkan dengan kebingungan data dan itu merupakan ide yang buruk merubah variabel di komponen child oleh komponen parent. Bagaimanapun, suatuwaktu sebuah komponen diijinkan untuk merubah, tapi state miliknya sendiri, sebagai contoh, merubah aktif atau sebuah waktu/ stopwath, sebagai contoh. Ketika hanya gunakan props sebisa mungkin, jangan dipaksakan, jika kita butuh untuk perubahan, makan gunakan state dikomponen, sebagaimana React berikan. state dalam komponen digunakan secara internal dan dapat diakses oleh komponen child (semua komponen child). Mirip bagaimana kita akses props disetiap komponen. kita bisa gunakan this.state disetiap komponen. Kapanpun state berubah (melalui this.setState() function), komponen akan melakkukan re-render ulang. Sebagai contoh, kita buat komponen jam, yang menampilkan waktu hari ini, bisa dicek di halaman play. Meskipun komponen jam itu terlihat mudah, tapi itu tidak menjelaskan state dimana waktu sedang berjalan. Tanpa state, kita tidak akan bisa melakukan perhitungan dan merender ulang komponen React, tapi komponen halaman/ utama tak perlu rendering ulang, mungkin membingungkan dan perlahan kita akan integrasikan menjadi aplikasi yang kompleks. Kita akan buat komponen kita namakan, Clock. Sebelum kita mencoba state, kita buat dahulu komponen dan fungsi render(). Kita butuh sebuah nomor dan angka nol (0) sebagai persiapan, jika nomor lebih kecil dari 10 dan kita set menjadi am/pm. Hasil akhir mungkin akan seperti ini: Live Editorclass Clock extends React.Component { render() { const currentTime = new Date(), hours = currentTime.getHours(), minutes = currentTime.getMinutes(), seconds = currentTime.getSeconds(), ampm = hours >= 12 ? \"pm\" : \"am\"; return ( <div className=\"clock\"> {hours == 0 ? 12 : hours > 12 ? hours - 12 : hours}: {minutes > 9 ? minutes : `0${minutes}`}: {seconds > 9 ? seconds : `0${seconds}`} {ampm} </div> ); } }class Clock extends React.Component { render() { const currentTime = new Date(), hours = currentTime.getHours(), minutes = currentTime.getMinutes(), seconds = currentTime.getSeconds(), ampm = hours >= 12 ? \"pm\" : \"am\"; return ( <div className=\"clock\"> {hours == 0 ? 12 : hours > 12 ? hours - 12 : hours}: {minutes > 9 ? minutes : `0${minutes}`}: {seconds > 9 ? seconds : `0${seconds}`} {ampm} </div> ); }}Result3: 01: 12 pm Altenative(\"00\" + minutes).slice(-2);CopyTapi kita contohkan yang mudah difahami. Jika kita render komponen Clock, kita akan lihat perubahan jika kita render ulang, dengan refresh halaman. Itu bukanlah jam yang berguna (saat ini). Untuk merubah waktu statis dalam komponen Clock kita akan ubah, agar waktu berubah setiap second. Untuk melakukannya, kita harus mencatat waktu sekarang dari komponen, untuk melakukannya, kita butuh sebuah inisiasi nilai state. Jadi, kita akan buat fungsi getTime() yang akan memberikan nilai dari jam, menit, dan detik dan nilai ampm. Kita akan buat fungsi untuk menyimpan state tersebut. class Clock extends React.Component { //... getTime() { const currentTime = new Date(); return { jam: currentTime.getHours(), menit: currentTime.getMinutes(), detik: currentTime.getSeconds(), ampm: currentTime.getHours() >= 12 ? \"pm\" : \"am\" }; } // ...}Copy diclass style ES6, kita bisa set state dikomponen pada constructor() dengan menggunakan nilai this.state (return dari fungsi getTime()). constructor(props) { super(props); this.state = this.getTime();}Copy this.state terlihat seperti sebuah objek { \"jam\": 11, \"menit\": 9, \"detik\": 11, \"ampm\": \"am\"}Copy warningHarap diperhatikan super(props) harus ada di constructor, jika tidak akan muncul eror Sekarang kita punya this.state yang sudah didefinisikan di komponen Clock, kita dapat letakkan di fungsi render(), sekarang kita ubah komponen Clock kita: class Clock extends React.Component { render() { const { jam, menit, detik, ampm } = this.state; return ( <div className=\"clock\"> {jam == 0 ? 12 : jam > 12 ? jam - 12 : jam}: {menit > 9 ? menit : `0${menit}`}:{detik > 9 ? detik : `0${detik}`}{\" \"} {ampm} </div> ); }}Copy Ketimbang kita ubah data secara langsung, kita bisa ubah sebuah state dari komponen dan memisahkan dengan fungsi render() untuk menajemen data saja. Dalam hal ini, kita bisa gunakan fungsi spesial, disebut dengan setState(), dimana akan mentrigger komponen untuk melakukan re-render ulang. Kita butuh setState() di nilai this pada komponen, dimana bagian dari class React.Component sebagai subclassing. Dikomponnen Clock kita gunakan fungsi bawaan Javascript setTimeout() untuk melakukan update waktu ke objek this.state setiap 1000 milisecond. Kita akan tempatkan sebagai function, yang dapat kita gunakan kapan saja. class Clock extends React.Component { consturctor(props) { super(props); this.state = this.getTime(); } componentDidMount() { this.setTimer(); } setTimer() { clearTimeout(this.timeout); this.timeout = setTimeout(this.updateClock.bind(this), 1000); } updateClock() { this.setState(this.getTime, this.setTimer); }}Copy Untuk perubahan waktu secara cepat setelah komponen dirender, kita gunakan this.setTimer() didalam komponen React sebagai lifecycle method, yaitu componentDidMount(). Kita akan perdalam, tentang lifecycle hooks, diselanjutnya. Dalam Fungsi updateClock() kita akan update setiap state dengan waktu yang baru. Komponen tersebut akan ter-set dihalaman dan akan berubah setiap waktu (mendekati 1000 milisconds). class Clock extends React.Component { // ... updateClock() { this.setState(this.getTime, this.setTimer); } // ...}Copy Sekarang komponen itu sendiri mungkin merender ulang lebih lama, saat pemanggilan fungsi tersebut, dimana terjadi semacam bootleneck dan menguras baterai jika diakses melalui smartphone. Ketimbang memanggil fungsi setTimer() setelah memanggil this.setState(), kita bisa tambahkan argumen kedua di fungsi this.setState(), dimana akan memastikan bahwa fungsi berjalan setelah ada update. class Clock extends React.Component { // ... updateClock() { const currentTime = new Date(); this.setState( { currentTime: currentTime }, this.setTimer ); } // ...}Copy Berikut ini full source code komponen Clock: Live Editorclass Clock extends React.Component { constructor(props) { super(props); this.state = this.getTime(); } componentDidMount() { this.setTimer(); } setTimer() { clearTimeout(this.timeout); this.timeout = setTimeout(this.updateClock.bind(this), 1000); } updateClock() { this.setState(this.getTime, this.setTimer); } getTime() { const currentTime = new Date(); return { jam: currentTime.getHours(), menit: currentTime.getMinutes(), detik: currentTime.getSeconds(), ampm: currentTime.getHours() >= 12 ? \"pm\" : \"am\" }; } render() { const { jam, menit, detik, ampm } = this.state; return ( <div className=\"clock\"> {jam == 0 ? 12 : jam > 12 ? jam - 12 : jam}: {menit > 9 ? menit : `0${menit}`}:{detik > 9 ? detik : `0${detik}`}{\" \"} {ampm} </div> ); } }class Clock extends React.Component { constructor(props) { super(props); this.state = this.getTime(); } componentDidMount() { this.setTimer(); } setTimer() { clearTimeout(this.timeout); this.timeout = setTimeout(this.updateClock.bind(this), 1000); } updateClock() { this.setState(this.getTime, this.setTimer); } getTime() { const currentTime = new Date(); return { jam: currentTime.getHours(), menit: currentTime.getMinutes(), detik: currentTime.getSeconds(), ampm: currentTime.getHours() >= 12 ? \"pm\" : \"am\" }; } render() { const { jam, menit, detik, ampm } = this.state; return ( <div className=\"clock\"> {jam == 0 ? 12 : jam > 12 ? jam - 12 : jam}: {menit > 9 ? menit : `0${menit}`}:{detik > 9 ? detik : `0${detik}`}{\" \"} {ampm} </div> ); }}Result3: 01:12 pm StaylesKita tidak fokus belajar dengan CSS. kita tidak akan bahas!. Bagaimanapun, jika ingin mirip seperti kami buat, silahkan gunakan css yang kami berikan:<link href=\"https://cdn.jsdelivr.net/gh/fullstackreact/30-days-of-react@master/day-06/public/Clock.css\" rel=\"stylesheet\" type=\"text/css\"/>Copy "
  },
  {
    "title": "Hal Yang Harus Diperhatikan",
    "type": 1,
    "pageTitle": "Hari Keenam - State",
    "url": "docs/hari6#hal-yang-harus-diperhatikan",
    "content": "Ketika memanggil this.setState() harus sebuah objek, hal itu untuk performa penggabungan data terhadap objek yang tersedia, lalu akan merender ulang.Secara umum, kita gunakan fungsi render() untuk menjaga agar nilai state tetap. Misal kita taro jam, menit dan detik difungsi render, ide yang kurang baik, karena akan membuang memory CPU secara sia-sia. sebagaimana kita jelaskan dibahasa ini, penggunaan props jika diperlukan saja, karena alasan performa, tapi juga karena komponen stateful sulit untuk dilakukan pengetesan. Hari ini, kita sudah ubah komponen menjadi stateful dan kita bisa gunakan untuk jika memang diperlukan. Selanjutnya, kita akan bahas lifecycle dari komponen kapan atau bagaimana berinteraksi dengan halaman web kita. "
  },
  {
    "title": "Hari Ketujuh - Siklus Hooks",
    "type": 0,
    "sectionRef": "#",
    "url": "docs/hari7",
    "content": ""
  },
  {
    "title": "componentWillmount()/ componentDidMount()",
    "type": 1,
    "pageTitle": "Hari Ketujuh - Siklus Hooks",
    "url": "docs/hari7#componentwillmount-componentdidmount",
    "content": "Ketika komponen dalam suatu aplikasi terlihat, kita tidak bisa menentukan secara langsung sebuah DOM sebagimana node virtual. Daripada kita menunggu komponen itu sendiri ter-set dibrowser. Sekedar fungsi saja, kita butuh ketika sudah siap (mounted), kita bisa memanfaatkan 2 hook atau fungsi secara beda. satu dipanggil sebelum komponen terset (mounted) dihalaman dan satu lagi dipanggil setelah komponen terset (mounted). "
  },
  {
    "title": "componentWillUpdate()/ componentDidUpdate()",
    "type": 1,
    "pageTitle": "Hari Ketujuh - Siklus Hooks",
    "url": "docs/hari7#componentwillupdate-componentdidupdate",
    "content": "Terkadang kita ingin merubah suatu data dikomponen kita sebelumnya atau setelah kita benar benar melakukan render. Sebagai contoh, kita ingin memanggil fungsi sebuah render, atau sebuah fungsi dimana perlu perubahan props dikomponen. Seubah methode componentWillUpdate() dapat mengatur komponen tersebut, selama kita tidak memanggil methode this.setState(), karena akan terjadi looping tanpa batas. Kita tidak akan fokus terlalu jauh, jangan kita hiraukan cara menggunakannya, tapi cukup tau sudah cukup kok. Yang akan kita pelajari lebih jauh siklus hook yaitu componentWillReceiveProps(). "
  },
  {
    "title": "DISKIP, KELARIN YANG NEW HOOKS DULU YA.",
    "type": 1,
    "pageTitle": "Hari Ketujuh - Siklus Hooks",
    "url": "docs/hari7#diskip-kelarin-yang-new-hooks-dulu-ya",
    "content": ""
  },
  {
    "title": "Apa artinya mounting ?",
    "type": 1,
    "pageTitle": "Hari Ketujuh - Siklus Hooks",
    "url": "docs/hari7#apa-artinya-mounting-",
    "content": "Ketika mendefinisikan sebuah tampilan virtual pada nodes dipohon (jejaring) DOM dengan React, sebenernya kita tidak mendifinisikan sebuah DOM secara langsung, melainkan kita sedang membangun sebuah tampilan di-dalam memori, dimana React yang bekerja dan mengatur untuk kita. Ketika membahas semuah mounting kita membicarakan sebuah proses konversi sebuah komponen virtual kedalam element DOM sebenernya dimana DOM itu berada, dan dilakukan oleh React. Hal ini bisa kita manfaatkan untuk mengambil data untuk dijabarkan di komponen. Sebagai contoh, kita ingin menampilkan aktifitas kegiatan github, sebagai contoh. Kita akan menampilkan semuanya, dan akan kita render. Tulis kembali komponen Isi sebelumnya: class Isi extends React.Component { render() { const { activities } = this.props; // ES6 destructuring return ( <div className=\"content\"> <div className=\"line\" /> {/* Timeline item */} {activities.map(activity => ( <ItemAktifitas activity={activity} /> ))} </div> ); }}Copy Kita akan ubah komponen Isi dimana kita akan gunakan API dari Github.com dan menampilkan respone ke layar. Baiklah, kita butuh yaitu mengupdate state objek yang tersedia. Sebagaimana kita pelajari kemarin, kita akan mengubah suatu state ke objek di constructor dengan this.state. constructor(props){ this.state = { activities:[] }}Copy baiklah sekarang kita akan buat sebuah permintaan melalui protokol HTTP, ketika komponen itu sudah siap untuk munted atau setelahnya. Dengan menggunakan fungsi siklus componentWillMount() atau componentDidMount() di komponen kita, React akan menjalankan sebelum ditampilkan ke DOM. Ini sangat pas untuk menambahkan permintaan GET. Kita akan ubah komponen Isi menggunakan permintaan API Github. Kita hanya menampilkan daftar yang kecil, baiklah kita akan tambahkan. JSONKita mengguna statik JSON File data Github kita gunakan untuk load data secara langsung disini (segera kita akan buat menjadi AJAX Request dalam beberapa hari kedepan) menggunakan promise. Untuk sekarang, kita fokus bagaimana mengimplementasikan komponen kita dengan sebuah data. componentWillMount() { this.setState({ activities: data })}Copy Baiklah ubah juga komponen ItemAktifitas yang dapat menampilkan struktur objek aktifitas. Kita gunakan Moment.js sebagai library memformat waktu yang mudah dibaca, misalkan 30 min ago, tambahkan script ini. <script src=\"https://unpkg.com/moment@2.24.0/min/moment.min.js\"></script> atau yarn add moment import moment from \"moment\";class ItemAktifitas extends Component { render() { const { activity } = this.props; return ( <div key={activity.pengguna.id} className=\"item\"> <div className=\"avatar\"> <img alt={activity.text} src={activity.pengguna.avatar} /> Doug </div> <span className=\"time\"> {moment(activity.created_at).fromNow()}</span> <p>{activity.text}</p> <div className=\"commentCount\">{activity.komentar.length}</div> </div> ); }}Copy Harap diperhatikan, kita tidak merubah apapun di komponen Isi. "
  },
  {
    "title": "componentWillReceiveProps()",
    "type": 1,
    "pageTitle": "Hari Ketujuh - Siklus Hooks",
    "url": "docs/hari7#componentwillreceiveprops",
    "content": "React akan menggunakan method ini ketika menerima sebuah props baru. Methode pertama yang digunakan sebuah komponen ketika menerima props baru. Mendefinisikan method ini sangat mudah untuk melihat perubahan secara detail di props sebagaimana kemudahan dalam mengkalkulasi dan merubah komponen state internal. inilah waktunya kita bisa merubah state berdasarkan props yang baru. 1 hal yang harus diingat, meski method componentWillReceiveProps() dipanggil, nilai value dari props mungkin tidak berubah. Itu ide bagus untuk mengecek perubahan nilai value di prop. Sebagai contoh, kita akan membuat tombol refresh di item aktifitas, agar pengguna dapat melakukan request ulang terhadap api github. Kita akan gunakan componentWillReceiveProps() untuk menanyakan ke komponen untuk mereload data. Karena komponen kita adalah stateful. Kita akan refresh state dengan yang baru, jadi kita mudah untuk merubah sebuah props di komponen. kita akan menggunakannya untuk sekedar memberitahukan saja. Baiklah, sekarang kita tambahkan tombol di komponen yang dapat menjalankan sebuah requestRefresh pada props pilihan, di kompoenen isi. class Isi extends React.Component { constructor(props) { super(props); this.state = { refreshing: false }; } refresh() { this.setState({ refreshing: true }); } // callback dari komponen isi onComponentRefresh() { this.setState({ refreshing: false }); } render() { const { refreshing } = this.state; return ( <div className=\"notificationsFrame\"> <div className=\"panel\"> <Header title=\"Github activity\" /> {/* refreshing is the component's state */} <Content onComponentRefresh={this.onComponentRefresh.bind(this)} requestRefresh={refreshing} fetchData={fetchEvents} /> {/* A container for styling */} <Footer> <button onClick={this.refresh.bind(this)}> <i className=\"fa fa-refresh\" /> Refresh </button> </Footer> </div> </div> ); }}Copy <Footer />Harap diperhatikan, kita buat elemen baru yang menampilkan anak dari element tampilan, pola ini digunakan untuk class CSS yang sama. class Footer extends React.Component { render() { return <div className=\"footer\">{this.props.childer}</div>; }}Copy "
  },
  {
    "title": "Hari Kedelapan",
    "type": 0,
    "sectionRef": "#",
    "url": "docs/hari8",
    "content": ""
  },
  {
    "title": "Hari Kesembilan",
    "type": 0,
    "sectionRef": "#",
    "url": "docs/hari9",
    "content": ""
  },
  {
    "title": "Pendahuluan",
    "type": 0,
    "sectionRef": "#",
    "url": "docs/intro",
    "content": ""
  },
  {
    "title": "Bismillahirrohmanirrohim",
    "type": 1,
    "pageTitle": "Pendahuluan",
    "url": "docs/intro#bismillahirrohmanirrohim",
    "content": "Selamat menikmati buku translate tentang ReactJS, translate secara manual dengan pemahaman saya sendiri, jika ada yang salah atau kurang pas silahkan pull atau email ke saya di desta@rsuppersahabatan.co.id dengan senang hati saya akan perbaiki. Untuk yang lebih suka dengan bahasa inggris langsung, silahkan akses dihalaman ini:  30 Days of Reacthttps://github.com/fullstackreact/30-days-of-react.git Sourcecode pelatihan hasil translate ini bisa diakses dihalaman git berikut ini: Codehttps://github.com/topidesta/30hariCode.git Saya juga menerima Jasa Pembuatan Manual Book untuk Private Company dengan Teknologi Docusaurus (ReactJS). Implementasi manual book di RSUP Persahabatan juga dibuat dengan Docusaurus, mohon maaf akses hanya bisa melalui jaringan lokal. Sekian, Wassalam. console.log(\"emang_dasar a.k.a topidesta\");Copy "
  },
  {
    "title": "Powered by MDX",
    "type": 0,
    "sectionRef": "#",
    "url": "docs/mdx",
    "content": "You can write JSX and use React components within your Markdown thanks to MDX. Docusaurus green and Facebook blue are my favorite colors.I can write Markdown alongside my JSX!"
  },
  {
    "title": "Hooks di React",
    "type": 0,
    "sectionRef": "#",
    "url": "docs/newhook",
    "content": ""
  },
  {
    "title": "Pengenalan Hooks di React",
    "type": 1,
    "pageTitle": "Hooks di React",
    "url": "docs/newhook#pengenalan-hooks-di-react",
    "content": "Jika sering baca twitter mungkin Hooks sebuah fiture react yang baru yang menakutkan, tapi mungkin anda akan bertanya, bagaimana cara kita menggunakannya?, dalam buku ini kita akan menjelaskan dengan contoh bagaimana menggunakan hook. "
  },
  {
    "title": "Cara Kerja Hooks",
    "type": 1,
    "pageTitle": "Hooks di React",
    "url": "docs/newhook#cara-kerja-hooks",
    "content": "Jika anda familiar dengan React, satu cara terbaik ialah memahami Hooks dengan cara bagaimana melihat kebiasan kita menggunakan \"class komponen\" dengan hooks. Menggunakan kembali komponen class kita akan sering: mengatur statemenggunakan siklus react seperti componentDidMount() dan componentDidUpdate()akses context (dengan setting contextType) dengan Hooks react, kita akan melakukan duplikasi atau kesamaan komponen functional: State komponen menggunakan hook useState()siklus react seperti componentDidMount() dan componentDidUpdate() menggunakan hook seperti useEffect().akses context menggunakan useContext() "
  },
  {
    "title": "Menggunakan Hooks",
    "type": 1,
    "pageTitle": "Hooks di React",
    "url": "docs/newhook#menggunakan-hooks",
    "content": "Kamu dapat memulai hooks dengan setting package.json dengan react dan react-dom dengan nama next. // package.json\"react\": \"next\",\"react-dom\": \"next\"Copy "
  },
  {
    "title": "Contoh Hook useState()",
    "type": 1,
    "pageTitle": "Hooks di React",
    "url": "docs/newhook#contoh-hook-usestate",
    "content": "State adalah bagian penting dari React. Mereka akan mengijinkan kita mendeklarasikan sebuat state variabel data yang digunakan di aplikasi kita. dengan Komponen class, kita biasa gunakan seperti berikut ini. class Contoh extends React.Component { constructor(props) { super(props); this.state = { count: 0 }; }}Copy Sebelum hooks, state selalu digunakan di komponen class, sudah disinggung sebelumnya, hooks bisa digunakan di komponen functional. Kita liat contoh dibawah. Disini kita akan membuat sebuah switch lampu SVG, dimana merubah warna tergantung state, disini kita gunakan hook useState. Berikut ini contoh keseluruhannya, kita akan bahas apa yang terjadi didalamnya. import React, { useState } from \"react\";import ReactDOM from \"react-dom\";import \"./styles.css\";function LightBulb() { let [light, setLight] = useState(0); const setOff = () => setLight(0); const setOn = () => setLight(1); let fillColor = light === 1 ? \"#ffbb73\" : \"#000000\"; return ( <div className=\"App\"> <div> <LightbulbSvg fillColor={fillColor} /> </div> <button onClick={setOff}>Off</button> <button onClick={setOn}>On</button> </div> );}function LightbulbSvg(props) { return ( /* Below is the markup for an SVG that is the shape of a lightbulb. The important part is the `fill`, where we set the color dynamically based on props */ <svg width=\"56px\" height=\"90px\" viewBox=\"0 0 56 90\" version=\"1.1\"> <defs /> <g id=\"Page-1\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\" > <g id=\"noun_bulb_1912567\" fill=\"#000000\" fill-rule=\"nonzero\"> <path d=\"M38.985,68.873 L17.015,68.873 C15.615,68.873 14.48,70.009 14.48,71.409 C14.48,72.809 15.615,73.944 17.015,73.944 L38.986,73.944 C40.386,73.944 41.521,72.809 41.521,71.409 C41.521,70.009 40.386,68.873 38.985,68.873 Z\" id=\"Shape\" /> <path d=\"M41.521,78.592 C41.521,77.192 40.386,76.057 38.986,76.057 L17.015,76.057 C15.615,76.057 14.48,77.192 14.48,78.592 C14.48,79.993 15.615,81.128 17.015,81.128 L38.986,81.128 C40.386,81.127 41.521,79.993 41.521,78.592 Z\" id=\"Shape\" /> <path d=\"M18.282,83.24 C17.114,83.24 16.793,83.952 17.559,84.83 L21.806,89.682 C21.961,89.858 22.273,90 22.508,90 L33.492,90 C33.726,90 34.039,89.858 34.193,89.682 L38.44,84.83 C39.207,83.952 38.885,83.24 37.717,83.24 L18.282,83.24 Z\" id=\"Shape\" /> <path d=\"M16.857,66.322 L39.142,66.322 C40.541,66.322 41.784,65.19 42.04,63.814 C44.63,49.959 55.886,41.575 55.886,27.887 C55.887,12.485 43.401,0 28,0 C12.599,0 0.113,12.485 0.113,27.887 C0.113,41.575 11.369,49.958 13.959,63.814 C14.216,65.19 15.458,66.322 16.857,66.322 Z\" id=\"Shape\" fill={props.fillColor} /> </g> </g> </svg> );}const rootElement = document.getElementById(\"root\");ReactDOM.render(<LightBulb />, rootElement);Copy https://mpnoljl19.csb.app/ "
  },
  {
    "title": "Contoh Hook useEffect()",
    "type": 1,
    "pageTitle": "Hooks di React",
    "url": "docs/newhook#contoh-hook-useeffect",
    "content": "Sebuah hook useEffect dapat membantu anda menambahkan performa disisi fungsi komponen. Bisa untuk pemanggilan API, perubahan DOM, semua yang kamu inginkan untuk 'menambahkan' sesuatu untuk terjadi. Dengan menggunakan hook useEffect, React mengetahui bahwa kamu peduli terhadap aksi setelah selesai dirender. Baiklah, kita akan melihat contohnya. Kita akan gunakan hook useEffect() untuk memanggil API dan mendapatkan responenya. import React, { useState, useEffect } from \"react\";import ReactDOM from \"react-dom\";function App() { let [names, setNames] = useState([]); useEffect(() => { fetch(\"https://uinames.com/api/?amount=25&region=nigeria\") .then(respone => respone.json()) .then(data => { setNames(data); }); }); return ( <div className=\"App\"> <div> {names.map((item, i) => ( <div key={i}> {item.name} {item.surname} </div> ))} </div> </div> );}const rootElement = document.getElementById(\"root\");ReactDOM.render(<App />, rootElement);Copy Dalam contoh ini kita gunakan keduanya, yaitu useState dan useEffect dikarenakan dapat memudahkan menampilkan API yang dipanggil menjadi sebuah state import React, { useState, useEffect } from \"react\";Copy "
  },
  {
    "title": "Contoh Hook useContext()",
    "type": 1,
    "pageTitle": "Hooks di React",
    "url": "docs/newhook#contoh-hook-usecontext",
    "content": ""
  },
  {
    "title": "Contoh Hook useRef()",
    "type": 1,
    "pageTitle": "Hooks di React",
    "url": "docs/newhook#contoh-hook-useref",
    "content": "Refs merupakan cara React dalam mengakses sebuah element dimethod render(). Jika kamu baru dalam React refs, kamu bisa baca pengenalan React Refs disini. Sebuah fungsi useRef() mengembalikan nilai dari sebuah objek ref. const refContainer = useRef(initialValue);Copy "
  },
  {
    "title": "Penggunaan Kostum Hook",
    "type": 1,
    "pageTitle": "Hooks di React",
    "url": "docs/newhook#penggunaan-kostum-hook",
    "content": ""
  },
  {
    "title": "Testing untuk React Hook",
    "type": 1,
    "pageTitle": "Hooks di React",
    "url": "docs/newhook#testing-untuk-react-hook",
    "content": ""
  },
  {
    "title": "Reaksi Komunitas terhadap Hook",
    "type": 1,
    "pageTitle": "Hooks di React",
    "url": "docs/newhook#reaksi-komunitas-terhadap-hook",
    "content": ""
  },
  {
    "title": "Perbedaan Hooks (Sumber Lain)",
    "type": 1,
    "pageTitle": "Hooks di React",
    "url": "docs/newhook#perbedaan-hooks-sumber-lain",
    "content": ""
  },
  {
    "title": "Masa Depan Hook",
    "type": 1,
    "pageTitle": "Hooks di React",
    "url": "docs/newhook#masa-depan-hook",
    "content": ""
  },
  {
    "title": "Sumberlain",
    "type": 1,
    "pageTitle": "Hooks di React",
    "url": "docs/newhook#sumberlain",
    "content": ""
  },
  {
    "title": "Motivasi dibalik Hook",
    "type": 1,
    "pageTitle": "Hooks di React",
    "url": "docs/newhook#motivasi-dibalik-hook",
    "content": "Ketika dasar design berdasarkan komponen, kita seringkali menggunakan berukangkali views diaplikasi, satu masalah utama buat developer React adalah, bagaimana menggunakan kembali komponen antara logika state (data). Ketika kita punya komponen yang saling membagi, dan itu bukan solusi untuk digunakan dan terkadang terjadi duplikasi logika di konstraktor dan method siklusnya. Ada beberapa cara secara tradisional misalkan, urutan komponen tertinggimerender props secara kompleks tapi pola keduanya punya gambaran yang akan menjadikan kode dasar menjadi sangat kompleks/ sulit. Hooks masih AlphaSebelum mendalami lebih jauh, harap dicatat, bahwa hook masih belum selesai, dan sering membuka dokumentasi resmi, untuk bacaan yang lebih mendalam, karena mereka suka menjelaskan lebih dalam apa itu Hooks. "
  },
  {
    "title": "Fungi hanya sebuah Komponen",
    "type": 1,
    "pageTitle": "Hooks di React",
    "url": "docs/newhook#fungi-hanya-sebuah-komponen",
    "content": "Dikode atas kita bisa liat kita menggunakan useState dari react. useState adalah cara terbaru yang biasa digunakan oleh this.state yang biasa kita gunakan. Selanjutnya, dicatat bahwa komponen tersebut adalah sebuah fungsi bukan sebuah class. Menarik! "
  },
  {
    "title": "Menulis dan Membaca State",
    "type": 1,
    "pageTitle": "Hooks di React",
    "url": "docs/newhook#menulis-dan-membaca-state",
    "content": "Dalam fungsi ini, kita menggunakan useState dalam menulis sebuah state variabel: let [light, setLight] = useState(0);Copy useState digunakan untuk mendeklarasikan sebuah variabel state dan kita bisa inisialisasikan dengan tipe apapun (tidak seperti sebuah class, kita butuh sebuah objek). seperti terlihat, kita menggunakan kembali nilai dari useState. nilai pertama, light dalam kasus ini, sebagai state default, seperti this.statenilai kedua, setLight merupakan fungsi untuk merubah nilai state pertama, seperti this.setState selanjutnya, kita akan buat 2 fungsi dimana setiap state punya nilai berbeda, yaitu 0 atau 1. const setOff = () => setLight(0);const setOn = () => setLight(1);Copy lalu, kita gunakan fungsi tersebut sebagai event handlers di tombol, seperti dibawah ini: <button onClick=\"{setOff}\">Off</button> <button onClick=\"{setOn}\">On</button>Copy "
  },
  {
    "title": "React mencatat Sebuah State",
    "type": 1,
    "pageTitle": "Hooks di React",
    "url": "docs/newhook#react-mencatat-sebuah-state",
    "content": "Ketika kita pencet \"On\", setOn terpanggil, dimana kita panggil dengan setLight(1) yang akan merubah nilai dari light untuk dirender. Sedikit seperti sulap, tapi inilah yang terjadi, dimana React mencatat semua nilai divariabel dan melewatkan di nilai baru untuk dilakukan render ulang dikomponen tersebut. Lalu, kita gunakan state sebelumnya untuk menentukan sebuah bohlam harus \"on\" atau tidak. Itu saja, kita akan isi warna dari SVG tergantung dari light. jika light 0 maka off, lalu isi warna fillColor dengan #00000 atau jika 1 (on) makan #ffbb73. "
  },
  {
    "title": "Beragam State",
    "type": 1,
    "pageTitle": "Hooks di React",
    "url": "docs/newhook#beragam-state",
    "content": "Ketika kita tidak menggunakan contoh diatas, kita bisa gunakan beragam state dengan memanggil useState lebih darisekali, sebagai contoh: let [light, setLight] = useState(0);let [count, setCount] = useState(10);let [name, setName] = useState(\"yomi\");Copy DICATAT!Untuk memanfaatkan sebuah Hooks, kita harus teliti. Hal yang utama ialah, hooks harus ditempatkan dibagian atas sebuah function kodingan anda. Lihat aturan maen mereka. "
  },
  {
    "title": "Ambil Data dan Ubah State",
    "type": 1,
    "pageTitle": "Hooks di React",
    "url": "docs/newhook#ambil-data-dan-ubah-state",
    "content": "Untuk menggunakannya, kita perlu sebuah tempat aksi menggunakan fungsi useEffect, kita lewatkan aksinya sebagai fungsi tak dikenali, sebagai argumen pertama. Dicontoh sebelumnya, kita memanggil sebuah endpoint API yang mengembalikan nilai berupa daftar nama. Ketika sudah di response, kita ubah menjadi sebuah JSON dan mengeset kestate dengan menggunakan setNames(data). let [names, setNames] = useState([]);useEffect(() => { fetch(\"https://uinames.com/api/?amount=25&region=nigeria\") .then(response => response.json()) .then(data => { setNames(data); });});Copy "
  },
  {
    "title": "Performa useEffect()",
    "type": 1,
    "pageTitle": "Hooks di React",
    "url": "docs/newhook#performa-useeffect",
    "content": "Ada hal yang harus dicatat dalam menggunakan useEffect yang kurasa saat ini. Pertama kita harus memikirkan, secara default, useEffect akan selalu dipanggil disetiap render, kabar baiknya kita tidak pusing memikirkan putaran data, tapi ada kabar buruknya, kita tidak ingin selalu ada request/ permintaan HTTP, setiap render ulang (dikasus ini). Untuk Kita bisa gunakan argumen kedua, dalam pemanfaatan useEffect, seperti yang kita lakukan sekarang. Argumen kedua dari useEffect adalah sebuah list variable yang ingin kita lihat dan selanjutnya kita hanya jalankan hanya ketika nilainya berubah. Dikasus ini, dicatat ya, kita menambahkan sebuah array kosong sebagai argumen kedua. Ini memberikan informasi ke React bahwa kita panggil ketika komponen sudah termounted. Untuk lebih dalam apa itu performa Effect, silahkan kehalaman ini. Begitu pula useState, useEffect dapat melewatkan beragam instance, dimana artinya kita dapat menambahkan beberapa fungsi useEffect sekaligus. "
  },
  {
    "title": "Point Utama",
    "type": 1,
    "pageTitle": "Hooks di React",
    "url": "docs/newhook#point-utama",
    "content": "Context dalam react merupakan cara untuk komponen child mengakses nilai dari komponen parent. Untuk memahaminya, ketika membangun aplikasi React, terkadang kita butuh sebuah nilai dari atas hingga kebawah seperti pohon. Tanpa context, melewati sebuah props tidak akan berjalan dikomponen dengan semestinya, dimana diperlukan. Tidak hanya merepotkan dalam melewatkan props dalam komponen, dapat juga pengenalan yang tidak benar saat selesai. Melewati prop hingga kebawah seperti tree (cabang), komponen yang tidak berelasi seperti saling terkait, biasa disebut 'props drilling'. Contex dalam react dapat menyelesaikan masalah dari 'props drilling' dengan mengijinkan nilai dari sebuah tree (cabang) komponen, ke setiap komponen yang membutuhkan nilai tersebut. "
  },
  {
    "title": "Cara Mudah menggunakan Context",
    "type": 1,
    "pageTitle": "Hooks di React",
    "url": "docs/newhook#cara-mudah-menggunakan-context",
    "content": "Dengan useContext, kita akan memanfaatkan Context begitu sangat mudah. Dengan fungsi useContext() sebagai sebuah objek, dimana sebuah nilai akan kembali dari React.createContext() dan mengembalikan nilai sebelumnya. Lihat contoh dibawah ini: import React, { useContext } from \"react\";import ReactDOM from \"react-dom\";const JediContext = React.createContext();function Display() { const value = useContext(JediContext); return <div>{value}, I am your Father.</div>;}function App() { return ( <JediContext.Provider value={\"Luke\"}> <Display /> </JediContext.Provider> );}const rootElement = document.getElementById(\"root\");ReactDOM.render(<App />, rootElement);Copy https://codesandbox.io/s/3q2x15l4rm Dalam kode tersebut, kita membuat sebuah context bernama JediContext menggunakan React.createContext(). Kita gunakan JediContext.Provider di komponen App dan mengeset nilai dengan nama \"Luke\". Yang artinya apapun context objek yang dibaca dalam sebuah tree, dapat diambil nilainya. Untuk membaca nilai kita membuat fungsi Display(), kita panggil useContext, kita tambahkan sebagai argumen di JediContext. Kita lewati objek context, yang kita dapatkan dari React.createContext dan secara otomatis nilainya akan keluar. Ketika ada perubahan, hook ini akan otomatis mentrigger untuk melakukan perbuahan dengan nilai terakhir. "
  },
  {
    "title": "Memanfaatkan untuk Aplikasi Besar",
    "type": 1,
    "pageTitle": "Hooks di React",
    "url": "docs/newhook#memanfaatkan-untuk-aplikasi-besar",
    "content": "Kita sudah buat JediContext diantara kedua komponen diatas, tapi dalam aplikasi yang besar, sebuah komponen Display dan App memungkinkan terdapat di file yang beda. Jadi bagaimana kita mengakses melalui sebuah file objek dari JediContext tersebut? Jawabannya ialah, kita akan buat sebuah file yang mengexport nilai dari JediContext. Sebagai contoh, kita akan buat sebuah file, bernama context.js, isinya mungkin seperti ini: const JediContext = React.createContext();export { JediContext };Copy dan didalam App.js dan Display.js, kita harus import dengan menuliskan seperti ini: import { JediContext } from \"./context.js\";Copy (Thanks, Dave!) "
  },
  {
    "title": "Form Input dan useRef()",
    "type": 1,
    "pageTitle": "Hooks di React",
    "url": "docs/newhook#form-input-dan-useref",
    "content": "Kita lihat contoh menggunakan hook useRef. import React, { useState, useRef } from \"react\";import ReactDOM from \"react-dom\";function App() { let [name, setName] = useState(\"Nate\"); let nameRef = useRef(); const submitButton = () => { setName(nameRef.current.value); }; return ( <div className=\"App\"> <p>{name}</p> <div> <input ref={nameRef} type=\"text\" /> <button type=\"button\" onClick={submitButton}> Submit </button> </div> </div> );}const rootElement = document.getElementById(\"root\");ReactDOM.render(<App />, rootElement);Copy Dalam contoh tersebut, kita menggunakan hook useRef() sebagai penghubung dari useState() dalam merender nilai dari tag input kedalam sebuah tag p. Sebuah ref sendiri dipakai kedalam variabel nameRef. Sebuah variabel nameRef dapat digunakan sebagai fild input dengan mensetting sebagai ref. Intinya, setiap konten dari fild input akan diakses oleh ref. Sebuah tombol submit memiliki onClick handler, dinamakan submitButton. Sebuah fungsi submitButton memanggil setName melalui useState. Kita sudah jelaskan useSate sebelumnya, setName akan digunakan untuk mengeset sebuah state name. Untuk mengambil nama dari tag input, kita akan gunakan nameRef.current.value. Ada hal lainnya yang harus jadi perhatian tentang useRef yaitu fakta bahwa kita bisa gunakan tidak hanya dengan attribue ref. "
  },
  {
    "title": "Testing dengan useState()",
    "type": 1,
    "pageTitle": "Hooks di React",
    "url": "docs/newhook#testing-dengan-usestate",
    "content": ""
  },
  {
    "title": "Testing dengan useEffect()",
    "type": 1,
    "pageTitle": "Hooks di React",
    "url": "docs/newhook#testing-dengan-useeffect",
    "content": ""
  },
  {
    "title": "Testing dengan useRef()",
    "type": 1,
    "pageTitle": "Hooks di React",
    "url": "docs/newhook#testing-dengan-useref",
    "content": ""
  },
  {
    "title": "Live Code",
    "type": 0,
    "sectionRef": "#",
    "url": "docs/play",
    "content": ""
  },
  {
    "title": "t is 15:01:12.",
    "type": 1,
    "pageTitle": "Live Code",
    "url": "docs/play#undefined",
    "content": ""
  },
  {
    "title": "Refs di Komponen React",
    "type": 0,
    "sectionRef": "#",
    "url": "docs/refs",
    "content": ""
  },
  {
    "title": "Kapan digunakan?",
    "type": 1,
    "pageTitle": "Refs di Komponen React",
    "url": "docs/refs#kapan-digunakan",
    "content": "Rekomendasi kami, menggunakan refs bisa berdasarkan situasi: Integrasi dengan pihak ketiga terkait liraries DOMTrigger animasi yang pentingMengatur focus, seleksi text dan memutar media Jadi kita sudah menentukan kapan kita bisa gunakan refs, bagaimana kita memanfaatkannya? "
  },
  {
    "title": "Menggunakan Refs di React",
    "type": 1,
    "pageTitle": "Refs di Komponen React",
    "url": "docs/refs#menggunakan-refs-di-react",
    "content": "Ada beberapa jalan, dimana kita bisa gunakan refs: React.createRef()Callback refsString refs (resmi)Forwaring refs Kita aka pecah dalam beberapa bagian ya. "
  },
  {
    "title": "React.createRef()",
    "type": 1,
    "pageTitle": "Refs di Komponen React",
    "url": "docs/refs#reactcreateref",
    "content": "Refs dapan dibuat menggunakan fungsi React.createRef() dan menambahkan elemen HTML di komponen React melalui attribut ref. Sebuah ref biasanya dibuat didalam konstruktor komponen, jadi secara singkat dapat digunakan oleh komponen. SEbagi contoh: class MyComponent extends React.Component { constructor(props) { super(props); this.firstRef = React.createRef(); } render() { return <div ref={this.firsRef} />; }}Copy Seperti yang anda lihat: sebuah ref dibuat di konstruktor sebagai this.firstRefdan ditugaskan sebagai ref di div didalam fungsi render(). Lihat contoh diatas, bagaimana menggunakan refs didalam komponen React. "
  },
  {
    "title": "Fokus sebuah Input Dengan Refs",
    "type": 1,
    "pageTitle": "Refs di Komponen React",
    "url": "docs/refs#fokus-sebuah-input-dengan-refs",
    "content": "Berikut contohnya: // Ref.jsclass CustomTextInput extends React.Component { constructor(props) { super(props); this.textInput = React.createRef(); this.focusTextInput = this.focusTextInput.bind(this); } focusTextInput() { // focus input text secara eksplisit di api DOM // Catat: kita akses dom node yang 'berjalan' this.textInput.current.focus(); } render() { // memberitahukan ke React bahwa kita mengasosiasikan ref ke <input> // dengan 'textInput' kita buat di konstruktor <div> <input type=\"text\" ref={this.textInput} /> <input type=\"button\" value=\"focus the text input\" onClick={this.focusTextInput} /> </div>; }}Copy https://codesandbox.io/s/jz0ow97kk9 Dikode blok diatas, kita buat sebuah tombol yang otomatis mengarahkan input focus ketika kita klik. Kita mulai dengan membuat sebuah instan ref dan mengirimkan ke this.textInput dimethod konstruktor dan menambahkan attribue ref ke field input. <input type=\"text\" ref={this.textInput} />Copy Harap diperhatikan, ketika attribut ref digunakan dalam element HTML (dalam hal ini field input), sebuah ref harus dituliskan di constructor (dengan React.createRef()) yang menerima element DOM dengan nilai sebelumnya (current). itu artinya untuk mengakses nilai DOM, kita butuh tulisan seperti ini: this.textInput.current;Copy Kolom input kedua, berupa tombol untuk klik agar bisa auto focus, ke inputan pertama. dengan attribue onClick menjalankan perintah dari fungsi this.focusTextInput. <input type=\"button\" value=\"Focus the text input\" onClick={this.focusTextInput}/>Copy Sebuah fungsi focusTextInput() digunakan oleh fungsi javascript sebagai standart DOM yaitu .focus() untuk menfokuskan cursor ke text box inputan. focusTextInput() { this.textInput.current.focus();}Copy Terakhir, sebuah fungsi focusTextInput digabungkan sebagai method konstruktor seperti ini: this.focusTextInput = this.focusTextInput.bind(this);Copy "
  },
  {
    "title": "Ambil Nilai dari ref",
    "type": 1,
    "pageTitle": "Refs di Komponen React",
    "url": "docs/refs#ambil-nilai-dari-ref",
    "content": "Dalam contoh ini, kita akan lihat bagaimana sebuah field input kita set ke sebuah ref dan dapatkan nilai dari ref itusendiri. Seperti contoh dibawah ini: https://codesandbox.io/s/j1jny2on83 Dalam contoh itu, kita buat sebuah field input dimana kita bisa isi nilainya. Lalu ketika tombol submit di klik, kita akan lihat nilai dari console log. // Ref.jsclass CustomTextInput extends React.Component { constructor(props) { super(props); // create a ref to store the textInput DOM element this.textInput = React.createRef(); } handleSubmit = e => { e.preventDefault(); console.log(this.textInput.current.value); }; render() { // tell React that we want to associate the <input> ref // with the `textInput` that we created in the constructor return ( <div> <form onSubmit={e => this.handleSubmit(e)}> <input type=\"text\" ref={this.textInput} /> <button>Submit</button> </form> </div> ); }}Copy Sekali lagi, kita menggunakan fungsi React.createRef() untuk membuat sebuah instan ref dan melakukan pencocokan ke variabel this.textInput. Di fungsi render, sebuah form terdiri dari field input dimana sebuah nilai kita ingin baca. Bagaimana kita bisa baca nilainya? ya, dengan mencocokan sebuah ref ke input dan membaca nilai dari ref tersebut. <input type=\"text\" ref={this.textInput} />Copy Sebuah form sendiri terdapat fungsi onSubmit dari this.handleSubmit dimana log dari nilai akan ditampilkan diconsole. handleSubmit = e => { e.preventDefault(); console.log(this.textInput.current.value);};Copy Dalam contoh, ada parameter e sebagai event objek. Kita menggunakan e.preventDefault() agar browser menerima submit dari tombol yang diklik, dan kita tidak ingin, ada aksi setelah diklik. Dalam contoh yang interaktif jika kita log this.textInput kita akan ditampilkan sebuah objek, seperti dibawah ini: > Object {current: HTMLInputElement}Copy Perhatikan, ada satu properti current, dimana itu sebuah HTMLInputElement. itu adalah sebuah input element DOM sendiri dan bukan nilai aselinya. Untuk dapat nilai dari tag input, kita akses dengan this.textInput.current.value seperti dibawah ini: handleSubmit = e => { e.preventDefault(); console.log(this.textInput.current.value);};Copy Menggunakan ref cara termudah untuk mendapatkan nilai dari sebuah control form, hanya mengambil sebuah ref ke field input dan mengambilnya ketika kita butuh. "
  },
  {
    "title": "Callback Refs",
    "type": 1,
    "pageTitle": "Refs di Komponen React",
    "url": "docs/refs#callback-refs",
    "content": "Sebuah callback ref adalah caralain dalam menggunakan ref di React. Dalam penggunaanya kita set sebuah ref properti sebagai sebuah fungsi callback. Ketika sebuah ref siap, React akan panggil fungsi tersebut, yang akan ditempelkan sebagai argumen pertama di elemen. https://codesandbox.io/s/xj03nxmqv4 berikut ini contoh kode lainnya. Seperti sebelumnya, contoh dibawah ini akan mengamil nilai dari sebuah tag input, tapi kita gunakan refs callback ya: // Refs.jsclass CustomTextInput extends React.Component { constructor(props); this.textInput = null; this.setTextInputRef = element => { this.textInput = element; } handleSubmit = e => { e.preventDefault(); console.log(this.textInput.value); } render(){ return( <div> <form onSubmit={e => this.handleSubmt(e)}> <input type=\"text\" ref={this.setTextInputRef} /> <button>Submit</button> </form> </div> ) }}Copy Dicontoh tersebut, sebuah tag input memiliki sebuah ref yang mengarah ke this.setTextInputRef React akan memanggil sebuah callback ref dengan element DOM ketika komponen termount, dan memanggilnya dengan nilai null ketika diunmount. (ref dipanggil sebelum siklus hook componentDidMount dan componentDidUpdate melakukan callback) "
  },
  {
    "title": "String Ref (API Turunan)",
    "type": 1,
    "pageTitle": "Refs di Komponen React",
    "url": "docs/refs#string-ref-api-turunan",
    "content": "Ada banyak cara mengeset sebuah ref, tapi ini adalah sebuah turunan dan sepertinya akan dialihfungsikan. Tapi, kita liat kode orang, jadi akan kita bahas disini. Dengan sebuah ref string, kita akan merubah tag input seperti dibawah ini: <input type=\"text\" ref=\"textInput\" />Copy dan kita lihat di komponen, kita mendapatkan nilai dengan this.refs.textInput.value tapi, sekali lagi, ini belum selesai dikode baru, karena APInya akan segera usang. "
  },
  {
    "title": "Meneruskan Refs",
    "type": 1,
    "pageTitle": "Refs di Komponen React",
    "url": "docs/refs#meneruskan-refs",
    "content": "Meneruskan sebuah refs merupakan teknik melempar sebuah ref ke komponen children. Sangat berguna saat ada kasus, menggunakan kembali librari komponen dan komponen paling atas (HOC). https://codesandbox.io/s/p5q8y5m86x // Ref.jsconst TextInput = React.forwardRef((props, ref) => { <input type=\"text\" placeholder=\"Hello world\" ref={ref} />;});const inputRef = React.createRef();class CustomTextInput extends React.Component { handleSubmit = e => { e.preventDefault(); console.log(inputRef.current.value); }; render() { return ( <div> <form onSubmit={e => this.handleSubmit(e)}> <TextInput ref={inputRef} /> <button>Submit</button> </form> </div> ); }}Copy meneruskan ref dapat memberikan sebuah komponen untuk mengambil alih sebuah ref yang diterima dan melewatkan ke sebuah komponen child. Dicontoh diatas, kita punya sebuah komponen dengan nama TextInput yang mempunyai child dimana berupa filed input. Jadi, bagaimana kita lewatkan atau meneruskan seubah ref ke sebuah input? Pertama, kita akan mulai dengan menuliskan sebuah ref dengan kode dibawah ini: const inputRef = React.createRef();Copy lalu, kita lewatkan sebuah ref ke <TextInput ref={inputRef}> dengan style atribute dari JSX. React akan meneruskan sebuah ref ke fungsi forwardRef sebagai argumen kedua. selanjutnya kita meneruskan sebuah argmen ref dari bawah ke <input ref={ref}>. Sekarang Sebuah nilai dari node DOM dapat diakses melalui inputRef.current. "
  },
  {
    "title": "Mengurutkan Komponen",
    "type": 1,
    "pageTitle": "Refs di Komponen React",
    "url": "docs/refs#mengurutkan-komponen",
    "content": "Akhirnya, kita akan melihat contoh lain penggunaan ref tapi dengan teknik komponen paling atas (HOC). https://codesandbox.io/s/m485ox9xp9 dicontoh tersebut, setiap kita pencet tombol, sebuah input akan tampil di console log. Sebuah input memiliki ref yang terhubung dan melewatkan/ meneruskan ke HOC. const Input = InputComponent => { const forwardRef = (props, ref) => { const onType = () => console.log(ref.current.value); return <InputComponent forwardRef={ref} onChange={onType} {...props} />; }; return React.forwardRef(forwardRef);};Copy Inilah yang disebut dengan HOC, dinamakan input dimana menerima InputComponent sebagai sebuah argumen. Dan juga mencata nilai dari ref yang tampil melalui console log setiap tombol dipencet. Didalam input HOC, fungsi forwardRef akan mengembalikan sebuah fungsi InputComponent dimana terdapat fungsi forwardRef. Sebuah komponen Input akan mengembalikan nilai. Selanjutnya, kita akan membuat sebuah komponen yang akan menjadi child dari input HOC. const TextInput = ({ forwarderRef, children, ...rest }) => ( <div> <input ref={forwardedRef} {...rest} /> {children} </div>);Copy Sebuah komponen diatas mempunya forwardedRef yang siap disatukan ke ref, sehingga sebuah field input dapat diterima oleh ref ketika sudah dirender didalam komponen child. Sebuah perubahan ...rest mengijinkan untuk spread sebuah props(hanya itu saja, melewatkan semua argmen di array rest sebagai props ke tag input). Jadi, bagaimana kita menggunakan komponen TextInput? seperti berikut ini: const InputField = Input(TextInput);class CustomTextInput extends Component { render() { const inputRef = React.createRef(); return <InputField ref={inputRef} />; }}Copy Akhirnya, seubah HOC input bersama dengan komponen child, TextInput sudah terset ke komponen InputField. Sebuah komponen InputField sudah dirender dengan ref sekaligus. "
  },
  {
    "title": "Kesimpulan",
    "type": 1,
    "pageTitle": "Refs di Komponen React",
    "url": "docs/refs#kesimpulan",
    "content": "Refs sangat bagus untuk digunakan untuk melewatkan data ke sebuah instan child, dimana sangat berbede jika melalui props dan state. Kamu harus berhatihati karena refs dapat memanipulasi DOM yang aseli, dan menggantinya sebagai virtual DOM, dimana sangat bertolak belakang dengan prinsip React. Jadi, ketika refs digunakan sebagai alur data dalam aplikasi jangan dijadikan methode bawaan, akan lebih hebat lagi jika digunakan hanya untuk baca data dari element DOM saja, ketika butuh saja. "
  }
]
    